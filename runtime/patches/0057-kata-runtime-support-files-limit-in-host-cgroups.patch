From 04011b8a08bb69aa01ca7045bdcb477c14d5feac Mon Sep 17 00:00:00 2001
From: holyfei <yangfeiyu20092010@163.com>
Date: Mon, 21 Sep 2020 19:27:11 +0800
Subject: [PATCH 5/5] kata-runtime: support --files-limit in host cgroups

reason: support --files-limit in host cgroups, like --files-limit 2000

Signed-off-by: yangfeiyu <yangfeiyu2@huawei.com>
---
 vendor/github.com/containerd/cgroups/files.go      |  142 +
 vendor/github.com/containerd/cgroups/metrics.pb.go | 5050 +++-----------------
 vendor/github.com/containerd/cgroups/subsystem.go  |    2 +
 vendor/github.com/containerd/cgroups/utils.go      |    2 +-
 .../opencontainers/runtime-spec/specs-go/config.go |    6 +
 virtcontainers/cgroups.go                          |   82 +
 virtcontainers/fileslimit/fileslimit.c             |   23 +
 virtcontainers/fileslimit/fileslimit.go            |   23 +
 virtcontainers/fileslimit/fileslimit.h             |   14 +
 virtcontainers/sandbox.go                          |   38 +-
 10 files changed, 1012 insertions(+), 4370 deletions(-)
 create mode 100644 vendor/github.com/containerd/cgroups/files.go
 create mode 100644 virtcontainers/fileslimit/fileslimit.c
 create mode 100644 virtcontainers/fileslimit/fileslimit.go
 create mode 100644 virtcontainers/fileslimit/fileslimit.h

diff --git a/vendor/github.com/containerd/cgroups/files.go b/vendor/github.com/containerd/cgroups/files.go
new file mode 100644
index 0000000..c8374c1
--- /dev/null
+++ b/vendor/github.com/containerd/cgroups/files.go
@@ -0,0 +1,142 @@
+/*
+Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.
+SPDX-License-Identifier: Apache-2.0
+Description: common functions
+Author: jiangpengfei
+Create: 2019-06-12
+*/
+
+package cgroups
+
+import (
+	"fmt"
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"strconv"
+	"strings"
+
+	specs "github.com/opencontainers/runtime-spec/specs-go"
+)
+
+func NewFiles(root string) *filesController {
+	return &filesController{
+		root: filepath.Join(root, string(Files)),
+	}
+}
+
+type filesController struct {
+	root string
+}
+
+type filesSettings struct {
+	name  string
+	value *uint64
+}
+
+func (f *filesController) Name() Name {
+	return Files
+}
+
+func (f *filesController) Path(path string) string {
+	return filepath.Join(f.root, path)
+}
+
+func (f *filesController) Create(path string, resources *specs.LinuxResources) error {
+	if err := os.MkdirAll(f.Path(path), defaultDirPerm); err != nil {
+		return err
+	}
+
+	if resources.Files == nil {
+		return nil
+	}
+
+	settings := getFilesSettings(resources)
+	for _, t := range settings {
+		if t.value != nil {
+			// If files.limit value equal 0, which regard as no limit
+			if *(t.value) == 0 {
+				if err := ioutil.WriteFile(
+					filepath.Join(f.Path(path), fmt.Sprintf("files.%s", t.name)),
+					[]byte("max"),
+					defaultFilePerm,
+				); err != nil {
+					return err
+				}
+			} else {
+				if err := ioutil.WriteFile(
+					filepath.Join(f.Path(path), fmt.Sprintf("files.%s", t.name)),
+					[]byte(strconv.FormatUint(*t.value, 10)),
+					defaultFilePerm,
+				); err != nil {
+					return err
+				}
+			}
+		}
+	}
+
+	return nil
+}
+
+func (f *filesController) Update(path string, resources *specs.LinuxResources) error {
+	return f.Create(path, resources)
+}
+
+func (f *filesController) Stat(path string, stats *Metrics) error {
+	usage, err := getCgroupParamUint(path, "files.usage")
+	if err != nil {
+		return fmt.Errorf("failed to parse files.usage - %s", err)
+	}
+
+	maxString, err := getCgroupParamString(path, "files.limit")
+	if err != nil {
+		return fmt.Errorf("failed to parse files.limit - %s", err)
+	}
+
+	// Default if files.limit == "max" is 0 -- which represents "no limit".
+	var max uint64
+	if maxString != "max" {
+		max, err = parseUint(maxString, 10, 64)
+		if err != nil {
+			return fmt.Errorf("failed to parse files.limit -- unable to parse %q as a uint from Cgroup file %q", maxString, filepath.Join(path, "file.limits"))
+		}
+	}
+
+	stats.Files.Usage = usage
+	stats.Files.Limit = max
+	return nil
+}
+
+func getFilesSettings(resources *specs.LinuxResources) []filesSettings {
+	return []filesSettings{
+		{
+			name:  "limit",
+			value: resources.Files.Limit,
+		},
+	}
+}
+
+// Gets a single uint64 value from the specified cgroup file.
+func getCgroupParamUint(cgroupPath, cgroupFile string) (uint64, error) {
+	fileName := filepath.Join(cgroupPath, cgroupFile)
+	contents, err := ioutil.ReadFile(fileName)
+	if err != nil {
+		return 0, err
+	}
+
+	res, err := parseUint(strings.TrimSpace(string(contents)), 10, 64)
+	if err != nil {
+		return res, fmt.Errorf("unable to parse %q as a uint from Cgroup file %q", string(contents), fileName)
+	}
+	return res, nil
+}
+
+// Gets a string value from the specified cgroup file
+func getCgroupParamString(cgroupPath, cgroupFile string) (string, error) {
+	contents, err := ioutil.ReadFile(filepath.Join(cgroupPath, cgroupFile))
+	if err != nil {
+		return "", err
+	}
+
+	return strings.TrimSpace(string(contents)), nil
+}
diff --git a/vendor/github.com/containerd/cgroups/metrics.pb.go b/vendor/github.com/containerd/cgroups/metrics.pb.go
index 7dd7f6f..652744d 100644
--- a/vendor/github.com/containerd/cgroups/metrics.pb.go
+++ b/vendor/github.com/containerd/cgroups/metrics.pb.go
@@ -2,37 +2,38 @@
 // source: github.com/containerd/cgroups/metrics.proto
 
 /*
-	Package cgroups is a generated protocol buffer package.
-
-	It is generated from these files:
-		github.com/containerd/cgroups/metrics.proto
-
-	It has these top-level messages:
-		Metrics
-		HugetlbStat
-		PidsStat
-		CPUStat
-		CPUUsage
-		Throttle
-		MemoryStat
-		MemoryEntry
-		BlkIOStat
-		BlkIOEntry
-		RdmaStat
-		RdmaEntry
-		NetworkStat
+Package cgroups is a generated protocol buffer package.
+
+It is generated from these files:
+	github.com/containerd/cgroups/metrics.proto
+
+It has these top-level messages:
+	Metrics
+	HugetlbStat
+	PidsStat
+	CPUStat
+	CPUUsage
+	Throttle
+	MemoryStat
+	MemoryEntry
+	BlkIOStat
+	BlkIOEntry
+	RdmaStat
+	RdmaEntry
+	NetworkStat
+	FilesStat
 */
 package cgroups
 
-import proto "github.com/gogo/protobuf/proto"
-import fmt "fmt"
-import math "math"
-import _ "github.com/gogo/protobuf/gogoproto"
+import (
+	fmt "fmt"
 
-import strings "strings"
-import reflect "reflect"
+	proto "github.com/gogo/protobuf/proto"
 
-import io "io"
+	math "math"
+
+	_ "github.com/gogo/protobuf/gogoproto"
+)
 
 // Reference imports to suppress errors if they are not otherwise used.
 var _ = proto.Marshal
@@ -53,12 +54,70 @@ type Metrics struct {
 	Blkio   *BlkIOStat     `protobuf:"bytes,5,opt,name=blkio" json:"blkio,omitempty"`
 	Rdma    *RdmaStat      `protobuf:"bytes,6,opt,name=rdma" json:"rdma,omitempty"`
 	Network []*NetworkStat `protobuf:"bytes,7,rep,name=network" json:"network,omitempty"`
+	Files   *FilesStat     `protobuf:"bytes,8,opt,name=files" json:"files,omitempty"`
 }
 
 func (m *Metrics) Reset()                    { *m = Metrics{} }
+func (m *Metrics) String() string            { return proto.CompactTextString(m) }
 func (*Metrics) ProtoMessage()               {}
 func (*Metrics) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{0} }
 
+func (m *Metrics) GetHugetlb() []*HugetlbStat {
+	if m != nil {
+		return m.Hugetlb
+	}
+	return nil
+}
+
+func (m *Metrics) GetPids() *PidsStat {
+	if m != nil {
+		return m.Pids
+	}
+	return nil
+}
+
+func (m *Metrics) GetCPU() *CPUStat {
+	if m != nil {
+		return m.CPU
+	}
+	return nil
+}
+
+func (m *Metrics) GetMemory() *MemoryStat {
+	if m != nil {
+		return m.Memory
+	}
+	return nil
+}
+
+func (m *Metrics) GetBlkio() *BlkIOStat {
+	if m != nil {
+		return m.Blkio
+	}
+	return nil
+}
+
+func (m *Metrics) GetRdma() *RdmaStat {
+	if m != nil {
+		return m.Rdma
+	}
+	return nil
+}
+
+func (m *Metrics) GetNetwork() []*NetworkStat {
+	if m != nil {
+		return m.Network
+	}
+	return nil
+}
+
+func (m *Metrics) GetFiles() *FilesStat {
+	if m != nil {
+		return m.Files
+	}
+	return nil
+}
+
 type HugetlbStat struct {
 	Usage    uint64 `protobuf:"varint,1,opt,name=usage,proto3" json:"usage,omitempty"`
 	Max      uint64 `protobuf:"varint,2,opt,name=max,proto3" json:"max,omitempty"`
@@ -67,27 +126,86 @@ type HugetlbStat struct {
 }
 
 func (m *HugetlbStat) Reset()                    { *m = HugetlbStat{} }
+func (m *HugetlbStat) String() string            { return proto.CompactTextString(m) }
 func (*HugetlbStat) ProtoMessage()               {}
 func (*HugetlbStat) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{1} }
 
+func (m *HugetlbStat) GetUsage() uint64 {
+	if m != nil {
+		return m.Usage
+	}
+	return 0
+}
+
+func (m *HugetlbStat) GetMax() uint64 {
+	if m != nil {
+		return m.Max
+	}
+	return 0
+}
+
+func (m *HugetlbStat) GetFailcnt() uint64 {
+	if m != nil {
+		return m.Failcnt
+	}
+	return 0
+}
+
+func (m *HugetlbStat) GetPagesize() string {
+	if m != nil {
+		return m.Pagesize
+	}
+	return ""
+}
+
 type PidsStat struct {
 	Current uint64 `protobuf:"varint,1,opt,name=current,proto3" json:"current,omitempty"`
 	Limit   uint64 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
 }
 
 func (m *PidsStat) Reset()                    { *m = PidsStat{} }
+func (m *PidsStat) String() string            { return proto.CompactTextString(m) }
 func (*PidsStat) ProtoMessage()               {}
 func (*PidsStat) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{2} }
 
+func (m *PidsStat) GetCurrent() uint64 {
+	if m != nil {
+		return m.Current
+	}
+	return 0
+}
+
+func (m *PidsStat) GetLimit() uint64 {
+	if m != nil {
+		return m.Limit
+	}
+	return 0
+}
+
 type CPUStat struct {
 	Usage      *CPUUsage `protobuf:"bytes,1,opt,name=usage" json:"usage,omitempty"`
 	Throttling *Throttle `protobuf:"bytes,2,opt,name=throttling" json:"throttling,omitempty"`
 }
 
 func (m *CPUStat) Reset()                    { *m = CPUStat{} }
+func (m *CPUStat) String() string            { return proto.CompactTextString(m) }
 func (*CPUStat) ProtoMessage()               {}
 func (*CPUStat) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{3} }
 
+func (m *CPUStat) GetUsage() *CPUUsage {
+	if m != nil {
+		return m.Usage
+	}
+	return nil
+}
+
+func (m *CPUStat) GetThrottling() *Throttle {
+	if m != nil {
+		return m.Throttling
+	}
+	return nil
+}
+
 type CPUUsage struct {
 	// values in nanoseconds
 	Total  uint64   `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
@@ -97,9 +215,38 @@ type CPUUsage struct {
 }
 
 func (m *CPUUsage) Reset()                    { *m = CPUUsage{} }
+func (m *CPUUsage) String() string            { return proto.CompactTextString(m) }
 func (*CPUUsage) ProtoMessage()               {}
 func (*CPUUsage) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{4} }
 
+func (m *CPUUsage) GetTotal() uint64 {
+	if m != nil {
+		return m.Total
+	}
+	return 0
+}
+
+func (m *CPUUsage) GetKernel() uint64 {
+	if m != nil {
+		return m.Kernel
+	}
+	return 0
+}
+
+func (m *CPUUsage) GetUser() uint64 {
+	if m != nil {
+		return m.User
+	}
+	return 0
+}
+
+func (m *CPUUsage) GetPerCPU() []uint64 {
+	if m != nil {
+		return m.PerCPU
+	}
+	return nil
+}
+
 type Throttle struct {
 	Periods          uint64 `protobuf:"varint,1,opt,name=periods,proto3" json:"periods,omitempty"`
 	ThrottledPeriods uint64 `protobuf:"varint,2,opt,name=throttled_periods,json=throttledPeriods,proto3" json:"throttled_periods,omitempty"`
@@ -107,9 +254,31 @@ type Throttle struct {
 }
 
 func (m *Throttle) Reset()                    { *m = Throttle{} }
+func (m *Throttle) String() string            { return proto.CompactTextString(m) }
 func (*Throttle) ProtoMessage()               {}
 func (*Throttle) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{5} }
 
+func (m *Throttle) GetPeriods() uint64 {
+	if m != nil {
+		return m.Periods
+	}
+	return 0
+}
+
+func (m *Throttle) GetThrottledPeriods() uint64 {
+	if m != nil {
+		return m.ThrottledPeriods
+	}
+	return 0
+}
+
+func (m *Throttle) GetThrottledTime() uint64 {
+	if m != nil {
+		return m.ThrottledTime
+	}
+	return 0
+}
+
 type MemoryStat struct {
 	Cache                   uint64       `protobuf:"varint,1,opt,name=cache,proto3" json:"cache,omitempty"`
 	RSS                     uint64       `protobuf:"varint,2,opt,name=rss,proto3" json:"rss,omitempty"`
@@ -150,4547 +319,698 @@ type MemoryStat struct {
 }
 
 func (m *MemoryStat) Reset()                    { *m = MemoryStat{} }
+func (m *MemoryStat) String() string            { return proto.CompactTextString(m) }
 func (*MemoryStat) ProtoMessage()               {}
 func (*MemoryStat) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{6} }
 
-type MemoryEntry struct {
-	Limit   uint64 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
-	Usage   uint64 `protobuf:"varint,2,opt,name=usage,proto3" json:"usage,omitempty"`
-	Max     uint64 `protobuf:"varint,3,opt,name=max,proto3" json:"max,omitempty"`
-	Failcnt uint64 `protobuf:"varint,4,opt,name=failcnt,proto3" json:"failcnt,omitempty"`
+func (m *MemoryStat) GetCache() uint64 {
+	if m != nil {
+		return m.Cache
+	}
+	return 0
 }
 
-func (m *MemoryEntry) Reset()                    { *m = MemoryEntry{} }
-func (*MemoryEntry) ProtoMessage()               {}
-func (*MemoryEntry) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{7} }
-
-type BlkIOStat struct {
-	IoServiceBytesRecursive []*BlkIOEntry `protobuf:"bytes,1,rep,name=io_service_bytes_recursive,json=ioServiceBytesRecursive" json:"io_service_bytes_recursive,omitempty"`
-	IoServicedRecursive     []*BlkIOEntry `protobuf:"bytes,2,rep,name=io_serviced_recursive,json=ioServicedRecursive" json:"io_serviced_recursive,omitempty"`
-	IoQueuedRecursive       []*BlkIOEntry `protobuf:"bytes,3,rep,name=io_queued_recursive,json=ioQueuedRecursive" json:"io_queued_recursive,omitempty"`
-	IoServiceTimeRecursive  []*BlkIOEntry `protobuf:"bytes,4,rep,name=io_service_time_recursive,json=ioServiceTimeRecursive" json:"io_service_time_recursive,omitempty"`
-	IoWaitTimeRecursive     []*BlkIOEntry `protobuf:"bytes,5,rep,name=io_wait_time_recursive,json=ioWaitTimeRecursive" json:"io_wait_time_recursive,omitempty"`
-	IoMergedRecursive       []*BlkIOEntry `protobuf:"bytes,6,rep,name=io_merged_recursive,json=ioMergedRecursive" json:"io_merged_recursive,omitempty"`
-	IoTimeRecursive         []*BlkIOEntry `protobuf:"bytes,7,rep,name=io_time_recursive,json=ioTimeRecursive" json:"io_time_recursive,omitempty"`
-	SectorsRecursive        []*BlkIOEntry `protobuf:"bytes,8,rep,name=sectors_recursive,json=sectorsRecursive" json:"sectors_recursive,omitempty"`
+func (m *MemoryStat) GetRSS() uint64 {
+	if m != nil {
+		return m.RSS
+	}
+	return 0
 }
 
-func (m *BlkIOStat) Reset()                    { *m = BlkIOStat{} }
-func (*BlkIOStat) ProtoMessage()               {}
-func (*BlkIOStat) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{8} }
-
-type BlkIOEntry struct {
-	Op     string `protobuf:"bytes,1,opt,name=op,proto3" json:"op,omitempty"`
-	Device string `protobuf:"bytes,2,opt,name=device,proto3" json:"device,omitempty"`
-	Major  uint64 `protobuf:"varint,3,opt,name=major,proto3" json:"major,omitempty"`
-	Minor  uint64 `protobuf:"varint,4,opt,name=minor,proto3" json:"minor,omitempty"`
-	Value  uint64 `protobuf:"varint,5,opt,name=value,proto3" json:"value,omitempty"`
+func (m *MemoryStat) GetRSSHuge() uint64 {
+	if m != nil {
+		return m.RSSHuge
+	}
+	return 0
 }
 
-func (m *BlkIOEntry) Reset()                    { *m = BlkIOEntry{} }
-func (*BlkIOEntry) ProtoMessage()               {}
-func (*BlkIOEntry) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{9} }
-
-type RdmaStat struct {
-	Current []*RdmaEntry `protobuf:"bytes,1,rep,name=current" json:"current,omitempty"`
-	Limit   []*RdmaEntry `protobuf:"bytes,2,rep,name=limit" json:"limit,omitempty"`
+func (m *MemoryStat) GetMappedFile() uint64 {
+	if m != nil {
+		return m.MappedFile
+	}
+	return 0
 }
 
-func (m *RdmaStat) Reset()                    { *m = RdmaStat{} }
-func (*RdmaStat) ProtoMessage()               {}
-func (*RdmaStat) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{10} }
-
-type RdmaEntry struct {
-	Device     string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
-	HcaHandles uint32 `protobuf:"varint,2,opt,name=hca_handles,json=hcaHandles,proto3" json:"hca_handles,omitempty"`
-	HcaObjects uint32 `protobuf:"varint,3,opt,name=hca_objects,json=hcaObjects,proto3" json:"hca_objects,omitempty"`
+func (m *MemoryStat) GetDirty() uint64 {
+	if m != nil {
+		return m.Dirty
+	}
+	return 0
 }
 
-func (m *RdmaEntry) Reset()                    { *m = RdmaEntry{} }
-func (*RdmaEntry) ProtoMessage()               {}
-func (*RdmaEntry) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{11} }
-
-type NetworkStat struct {
-	Name      string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
-	RxBytes   uint64 `protobuf:"varint,2,opt,name=rx_bytes,json=rxBytes,proto3" json:"rx_bytes,omitempty"`
-	RxPackets uint64 `protobuf:"varint,3,opt,name=rx_packets,json=rxPackets,proto3" json:"rx_packets,omitempty"`
-	RxErrors  uint64 `protobuf:"varint,4,opt,name=rx_errors,json=rxErrors,proto3" json:"rx_errors,omitempty"`
-	RxDropped uint64 `protobuf:"varint,5,opt,name=rx_dropped,json=rxDropped,proto3" json:"rx_dropped,omitempty"`
-	TxBytes   uint64 `protobuf:"varint,6,opt,name=tx_bytes,json=txBytes,proto3" json:"tx_bytes,omitempty"`
-	TxPackets uint64 `protobuf:"varint,7,opt,name=tx_packets,json=txPackets,proto3" json:"tx_packets,omitempty"`
-	TxErrors  uint64 `protobuf:"varint,8,opt,name=tx_errors,json=txErrors,proto3" json:"tx_errors,omitempty"`
-	TxDropped uint64 `protobuf:"varint,9,opt,name=tx_dropped,json=txDropped,proto3" json:"tx_dropped,omitempty"`
+func (m *MemoryStat) GetWriteback() uint64 {
+	if m != nil {
+		return m.Writeback
+	}
+	return 0
 }
 
-func (m *NetworkStat) Reset()                    { *m = NetworkStat{} }
-func (*NetworkStat) ProtoMessage()               {}
-func (*NetworkStat) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{12} }
-
-func init() {
-	proto.RegisterType((*Metrics)(nil), "io.containerd.cgroups.v1.Metrics")
-	proto.RegisterType((*HugetlbStat)(nil), "io.containerd.cgroups.v1.HugetlbStat")
-	proto.RegisterType((*PidsStat)(nil), "io.containerd.cgroups.v1.PidsStat")
-	proto.RegisterType((*CPUStat)(nil), "io.containerd.cgroups.v1.CPUStat")
-	proto.RegisterType((*CPUUsage)(nil), "io.containerd.cgroups.v1.CPUUsage")
-	proto.RegisterType((*Throttle)(nil), "io.containerd.cgroups.v1.Throttle")
-	proto.RegisterType((*MemoryStat)(nil), "io.containerd.cgroups.v1.MemoryStat")
-	proto.RegisterType((*MemoryEntry)(nil), "io.containerd.cgroups.v1.MemoryEntry")
-	proto.RegisterType((*BlkIOStat)(nil), "io.containerd.cgroups.v1.BlkIOStat")
-	proto.RegisterType((*BlkIOEntry)(nil), "io.containerd.cgroups.v1.BlkIOEntry")
-	proto.RegisterType((*RdmaStat)(nil), "io.containerd.cgroups.v1.RdmaStat")
-	proto.RegisterType((*RdmaEntry)(nil), "io.containerd.cgroups.v1.RdmaEntry")
-	proto.RegisterType((*NetworkStat)(nil), "io.containerd.cgroups.v1.NetworkStat")
-}
-func (m *Metrics) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetPgPgIn() uint64 {
+	if m != nil {
+		return m.PgPgIn
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if len(m.Hugetlb) > 0 {
-		for _, msg := range m.Hugetlb {
-			dAtA[i] = 0xa
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
-	}
-	if m.Pids != nil {
-		dAtA[i] = 0x12
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Pids.Size()))
-		n1, err := m.Pids.MarshalTo(dAtA[i:])
-		if err != nil {
-			return 0, err
-		}
-		i += n1
-	}
-	if m.CPU != nil {
-		dAtA[i] = 0x1a
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.CPU.Size()))
-		n2, err := m.CPU.MarshalTo(dAtA[i:])
-		if err != nil {
-			return 0, err
-		}
-		i += n2
+func (m *MemoryStat) GetPgPgOut() uint64 {
+	if m != nil {
+		return m.PgPgOut
 	}
-	if m.Memory != nil {
-		dAtA[i] = 0x22
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Memory.Size()))
-		n3, err := m.Memory.MarshalTo(dAtA[i:])
-		if err != nil {
-			return 0, err
-		}
-		i += n3
-	}
-	if m.Blkio != nil {
-		dAtA[i] = 0x2a
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Blkio.Size()))
-		n4, err := m.Blkio.MarshalTo(dAtA[i:])
-		if err != nil {
-			return 0, err
-		}
-		i += n4
-	}
-	if m.Rdma != nil {
-		dAtA[i] = 0x32
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Rdma.Size()))
-		n5, err := m.Rdma.MarshalTo(dAtA[i:])
-		if err != nil {
-			return 0, err
-		}
-		i += n5
-	}
-	if len(m.Network) > 0 {
-		for _, msg := range m.Network {
-			dAtA[i] = 0x3a
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
-	}
-	return i, nil
+	return 0
 }
 
-func (m *HugetlbStat) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetPgFault() uint64 {
+	if m != nil {
+		return m.PgFault
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *HugetlbStat) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if m.Usage != 0 {
-		dAtA[i] = 0x8
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Usage))
-	}
-	if m.Max != 0 {
-		dAtA[i] = 0x10
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Max))
-	}
-	if m.Failcnt != 0 {
-		dAtA[i] = 0x18
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Failcnt))
-	}
-	if len(m.Pagesize) > 0 {
-		dAtA[i] = 0x22
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Pagesize)))
-		i += copy(dAtA[i:], m.Pagesize)
+func (m *MemoryStat) GetPgMajFault() uint64 {
+	if m != nil {
+		return m.PgMajFault
 	}
-	return i, nil
+	return 0
 }
 
-func (m *PidsStat) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetInactiveAnon() uint64 {
+	if m != nil {
+		return m.InactiveAnon
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *PidsStat) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if m.Current != 0 {
-		dAtA[i] = 0x8
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Current))
+func (m *MemoryStat) GetActiveAnon() uint64 {
+	if m != nil {
+		return m.ActiveAnon
 	}
-	if m.Limit != 0 {
-		dAtA[i] = 0x10
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Limit))
-	}
-	return i, nil
+	return 0
 }
 
-func (m *CPUStat) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetInactiveFile() uint64 {
+	if m != nil {
+		return m.InactiveFile
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *CPUStat) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if m.Usage != nil {
-		dAtA[i] = 0xa
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Usage.Size()))
-		n6, err := m.Usage.MarshalTo(dAtA[i:])
-		if err != nil {
-			return 0, err
-		}
-		i += n6
-	}
-	if m.Throttling != nil {
-		dAtA[i] = 0x12
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Throttling.Size()))
-		n7, err := m.Throttling.MarshalTo(dAtA[i:])
-		if err != nil {
-			return 0, err
-		}
-		i += n7
+func (m *MemoryStat) GetActiveFile() uint64 {
+	if m != nil {
+		return m.ActiveFile
 	}
-	return i, nil
+	return 0
 }
 
-func (m *CPUUsage) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetUnevictable() uint64 {
+	if m != nil {
+		return m.Unevictable
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *CPUUsage) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if m.Total != 0 {
-		dAtA[i] = 0x8
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Total))
-	}
-	if m.Kernel != 0 {
-		dAtA[i] = 0x10
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Kernel))
-	}
-	if m.User != 0 {
-		dAtA[i] = 0x18
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.User))
+func (m *MemoryStat) GetHierarchicalMemoryLimit() uint64 {
+	if m != nil {
+		return m.HierarchicalMemoryLimit
 	}
-	if len(m.PerCPU) > 0 {
-		dAtA9 := make([]byte, len(m.PerCPU)*10)
-		var j8 int
-		for _, num := range m.PerCPU {
-			for num >= 1<<7 {
-				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
-				num >>= 7
-				j8++
-			}
-			dAtA9[j8] = uint8(num)
-			j8++
-		}
-		dAtA[i] = 0x22
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(j8))
-		i += copy(dAtA[i:], dAtA9[:j8])
-	}
-	return i, nil
+	return 0
 }
 
-func (m *Throttle) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetHierarchicalSwapLimit() uint64 {
+	if m != nil {
+		return m.HierarchicalSwapLimit
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *Throttle) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if m.Periods != 0 {
-		dAtA[i] = 0x8
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Periods))
-	}
-	if m.ThrottledPeriods != 0 {
-		dAtA[i] = 0x10
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.ThrottledPeriods))
+func (m *MemoryStat) GetTotalCache() uint64 {
+	if m != nil {
+		return m.TotalCache
 	}
-	if m.ThrottledTime != 0 {
-		dAtA[i] = 0x18
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.ThrottledTime))
-	}
-	return i, nil
+	return 0
 }
 
-func (m *MemoryStat) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetTotalRSS() uint64 {
+	if m != nil {
+		return m.TotalRSS
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *MemoryStat) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if m.Cache != 0 {
-		dAtA[i] = 0x8
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Cache))
-	}
-	if m.RSS != 0 {
-		dAtA[i] = 0x10
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.RSS))
-	}
-	if m.RSSHuge != 0 {
-		dAtA[i] = 0x18
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.RSSHuge))
-	}
-	if m.MappedFile != 0 {
-		dAtA[i] = 0x20
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.MappedFile))
-	}
-	if m.Dirty != 0 {
-		dAtA[i] = 0x28
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Dirty))
-	}
-	if m.Writeback != 0 {
-		dAtA[i] = 0x30
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Writeback))
-	}
-	if m.PgPgIn != 0 {
-		dAtA[i] = 0x38
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.PgPgIn))
-	}
-	if m.PgPgOut != 0 {
-		dAtA[i] = 0x40
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.PgPgOut))
-	}
-	if m.PgFault != 0 {
-		dAtA[i] = 0x48
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.PgFault))
-	}
-	if m.PgMajFault != 0 {
-		dAtA[i] = 0x50
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.PgMajFault))
-	}
-	if m.InactiveAnon != 0 {
-		dAtA[i] = 0x58
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.InactiveAnon))
-	}
-	if m.ActiveAnon != 0 {
-		dAtA[i] = 0x60
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.ActiveAnon))
-	}
-	if m.InactiveFile != 0 {
-		dAtA[i] = 0x68
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.InactiveFile))
-	}
-	if m.ActiveFile != 0 {
-		dAtA[i] = 0x70
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.ActiveFile))
-	}
-	if m.Unevictable != 0 {
-		dAtA[i] = 0x78
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Unevictable))
-	}
-	if m.HierarchicalMemoryLimit != 0 {
-		dAtA[i] = 0x80
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.HierarchicalMemoryLimit))
-	}
-	if m.HierarchicalSwapLimit != 0 {
-		dAtA[i] = 0x88
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.HierarchicalSwapLimit))
-	}
-	if m.TotalCache != 0 {
-		dAtA[i] = 0x90
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalCache))
-	}
-	if m.TotalRSS != 0 {
-		dAtA[i] = 0x98
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalRSS))
-	}
-	if m.TotalRSSHuge != 0 {
-		dAtA[i] = 0xa0
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalRSSHuge))
-	}
-	if m.TotalMappedFile != 0 {
-		dAtA[i] = 0xa8
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalMappedFile))
-	}
-	if m.TotalDirty != 0 {
-		dAtA[i] = 0xb0
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalDirty))
-	}
-	if m.TotalWriteback != 0 {
-		dAtA[i] = 0xb8
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalWriteback))
+func (m *MemoryStat) GetTotalRSSHuge() uint64 {
+	if m != nil {
+		return m.TotalRSSHuge
 	}
-	if m.TotalPgPgIn != 0 {
-		dAtA[i] = 0xc0
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalPgPgIn))
-	}
-	if m.TotalPgPgOut != 0 {
-		dAtA[i] = 0xc8
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalPgPgOut))
-	}
-	if m.TotalPgFault != 0 {
-		dAtA[i] = 0xd0
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalPgFault))
-	}
-	if m.TotalPgMajFault != 0 {
-		dAtA[i] = 0xd8
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalPgMajFault))
-	}
-	if m.TotalInactiveAnon != 0 {
-		dAtA[i] = 0xe0
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalInactiveAnon))
-	}
-	if m.TotalActiveAnon != 0 {
-		dAtA[i] = 0xe8
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalActiveAnon))
-	}
-	if m.TotalInactiveFile != 0 {
-		dAtA[i] = 0xf0
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalInactiveFile))
-	}
-	if m.TotalActiveFile != 0 {
-		dAtA[i] = 0xf8
-		i++
-		dAtA[i] = 0x1
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalActiveFile))
-	}
-	if m.TotalUnevictable != 0 {
-		dAtA[i] = 0x80
-		i++
-		dAtA[i] = 0x2
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalUnevictable))
-	}
-	if m.Usage != nil {
-		dAtA[i] = 0x8a
-		i++
-		dAtA[i] = 0x2
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Usage.Size()))
-		n10, err := m.Usage.MarshalTo(dAtA[i:])
-		if err != nil {
-			return 0, err
-		}
-		i += n10
-	}
-	if m.Swap != nil {
-		dAtA[i] = 0x92
-		i++
-		dAtA[i] = 0x2
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Swap.Size()))
-		n11, err := m.Swap.MarshalTo(dAtA[i:])
-		if err != nil {
-			return 0, err
-		}
-		i += n11
-	}
-	if m.Kernel != nil {
-		dAtA[i] = 0x9a
-		i++
-		dAtA[i] = 0x2
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Kernel.Size()))
-		n12, err := m.Kernel.MarshalTo(dAtA[i:])
-		if err != nil {
-			return 0, err
-		}
-		i += n12
-	}
-	if m.KernelTCP != nil {
-		dAtA[i] = 0xa2
-		i++
-		dAtA[i] = 0x2
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.KernelTCP.Size()))
-		n13, err := m.KernelTCP.MarshalTo(dAtA[i:])
-		if err != nil {
-			return 0, err
-		}
-		i += n13
-	}
-	return i, nil
+	return 0
 }
 
-func (m *MemoryEntry) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetTotalMappedFile() uint64 {
+	if m != nil {
+		return m.TotalMappedFile
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *MemoryEntry) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if m.Limit != 0 {
-		dAtA[i] = 0x8
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Limit))
-	}
-	if m.Usage != 0 {
-		dAtA[i] = 0x10
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Usage))
+func (m *MemoryStat) GetTotalDirty() uint64 {
+	if m != nil {
+		return m.TotalDirty
 	}
-	if m.Max != 0 {
-		dAtA[i] = 0x18
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Max))
-	}
-	if m.Failcnt != 0 {
-		dAtA[i] = 0x20
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Failcnt))
-	}
-	return i, nil
+	return 0
 }
 
-func (m *BlkIOStat) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetTotalWriteback() uint64 {
+	if m != nil {
+		return m.TotalWriteback
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *BlkIOStat) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if len(m.IoServiceBytesRecursive) > 0 {
-		for _, msg := range m.IoServiceBytesRecursive {
-			dAtA[i] = 0xa
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
-	}
-	if len(m.IoServicedRecursive) > 0 {
-		for _, msg := range m.IoServicedRecursive {
-			dAtA[i] = 0x12
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
-	}
-	if len(m.IoQueuedRecursive) > 0 {
-		for _, msg := range m.IoQueuedRecursive {
-			dAtA[i] = 0x1a
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
-	}
-	if len(m.IoServiceTimeRecursive) > 0 {
-		for _, msg := range m.IoServiceTimeRecursive {
-			dAtA[i] = 0x22
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
-	}
-	if len(m.IoWaitTimeRecursive) > 0 {
-		for _, msg := range m.IoWaitTimeRecursive {
-			dAtA[i] = 0x2a
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
-	}
-	if len(m.IoMergedRecursive) > 0 {
-		for _, msg := range m.IoMergedRecursive {
-			dAtA[i] = 0x32
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
+func (m *MemoryStat) GetTotalPgPgIn() uint64 {
+	if m != nil {
+		return m.TotalPgPgIn
 	}
-	if len(m.IoTimeRecursive) > 0 {
-		for _, msg := range m.IoTimeRecursive {
-			dAtA[i] = 0x3a
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
-	}
-	if len(m.SectorsRecursive) > 0 {
-		for _, msg := range m.SectorsRecursive {
-			dAtA[i] = 0x42
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
-	}
-	return i, nil
+	return 0
 }
 
-func (m *BlkIOEntry) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetTotalPgPgOut() uint64 {
+	if m != nil {
+		return m.TotalPgPgOut
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *BlkIOEntry) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if len(m.Op) > 0 {
-		dAtA[i] = 0xa
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Op)))
-		i += copy(dAtA[i:], m.Op)
-	}
-	if len(m.Device) > 0 {
-		dAtA[i] = 0x12
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Device)))
-		i += copy(dAtA[i:], m.Device)
-	}
-	if m.Major != 0 {
-		dAtA[i] = 0x18
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Major))
+func (m *MemoryStat) GetTotalPgFault() uint64 {
+	if m != nil {
+		return m.TotalPgFault
 	}
-	if m.Minor != 0 {
-		dAtA[i] = 0x20
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Minor))
-	}
-	if m.Value != 0 {
-		dAtA[i] = 0x28
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.Value))
-	}
-	return i, nil
+	return 0
 }
 
-func (m *RdmaStat) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetTotalPgMajFault() uint64 {
+	if m != nil {
+		return m.TotalPgMajFault
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *RdmaStat) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if len(m.Current) > 0 {
-		for _, msg := range m.Current {
-			dAtA[i] = 0xa
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
-	}
-	if len(m.Limit) > 0 {
-		for _, msg := range m.Limit {
-			dAtA[i] = 0x12
-			i++
-			i = encodeVarintMetrics(dAtA, i, uint64(msg.Size()))
-			n, err := msg.MarshalTo(dAtA[i:])
-			if err != nil {
-				return 0, err
-			}
-			i += n
-		}
+func (m *MemoryStat) GetTotalInactiveAnon() uint64 {
+	if m != nil {
+		return m.TotalInactiveAnon
 	}
-	return i, nil
+	return 0
 }
 
-func (m *RdmaEntry) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetTotalActiveAnon() uint64 {
+	if m != nil {
+		return m.TotalActiveAnon
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *RdmaEntry) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if len(m.Device) > 0 {
-		dAtA[i] = 0xa
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Device)))
-		i += copy(dAtA[i:], m.Device)
+func (m *MemoryStat) GetTotalInactiveFile() uint64 {
+	if m != nil {
+		return m.TotalInactiveFile
 	}
-	if m.HcaHandles != 0 {
-		dAtA[i] = 0x10
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.HcaHandles))
-	}
-	if m.HcaObjects != 0 {
-		dAtA[i] = 0x18
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.HcaObjects))
-	}
-	return i, nil
+	return 0
 }
 
-func (m *NetworkStat) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalTo(dAtA)
-	if err != nil {
-		return nil, err
+func (m *MemoryStat) GetTotalActiveFile() uint64 {
+	if m != nil {
+		return m.TotalActiveFile
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *NetworkStat) MarshalTo(dAtA []byte) (int, error) {
-	var i int
-	_ = i
-	var l int
-	_ = l
-	if len(m.Name) > 0 {
-		dAtA[i] = 0xa
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Name)))
-		i += copy(dAtA[i:], m.Name)
-	}
-	if m.RxBytes != 0 {
-		dAtA[i] = 0x10
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.RxBytes))
-	}
-	if m.RxPackets != 0 {
-		dAtA[i] = 0x18
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.RxPackets))
-	}
-	if m.RxErrors != 0 {
-		dAtA[i] = 0x20
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.RxErrors))
-	}
-	if m.RxDropped != 0 {
-		dAtA[i] = 0x28
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.RxDropped))
-	}
-	if m.TxBytes != 0 {
-		dAtA[i] = 0x30
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TxBytes))
-	}
-	if m.TxPackets != 0 {
-		dAtA[i] = 0x38
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TxPackets))
+func (m *MemoryStat) GetTotalUnevictable() uint64 {
+	if m != nil {
+		return m.TotalUnevictable
 	}
-	if m.TxErrors != 0 {
-		dAtA[i] = 0x40
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TxErrors))
-	}
-	if m.TxDropped != 0 {
-		dAtA[i] = 0x48
-		i++
-		i = encodeVarintMetrics(dAtA, i, uint64(m.TxDropped))
-	}
-	return i, nil
+	return 0
 }
 
-func encodeVarintMetrics(dAtA []byte, offset int, v uint64) int {
-	for v >= 1<<7 {
-		dAtA[offset] = uint8(v&0x7f | 0x80)
-		v >>= 7
-		offset++
+func (m *MemoryStat) GetUsage() *MemoryEntry {
+	if m != nil {
+		return m.Usage
 	}
-	dAtA[offset] = uint8(v)
-	return offset + 1
+	return nil
 }
-func (m *Metrics) Size() (n int) {
-	var l int
-	_ = l
-	if len(m.Hugetlb) > 0 {
-		for _, e := range m.Hugetlb {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
-	}
-	if m.Pids != nil {
-		l = m.Pids.Size()
-		n += 1 + l + sovMetrics(uint64(l))
-	}
-	if m.CPU != nil {
-		l = m.CPU.Size()
-		n += 1 + l + sovMetrics(uint64(l))
-	}
-	if m.Memory != nil {
-		l = m.Memory.Size()
-		n += 1 + l + sovMetrics(uint64(l))
-	}
-	if m.Blkio != nil {
-		l = m.Blkio.Size()
-		n += 1 + l + sovMetrics(uint64(l))
-	}
-	if m.Rdma != nil {
-		l = m.Rdma.Size()
-		n += 1 + l + sovMetrics(uint64(l))
-	}
-	if len(m.Network) > 0 {
-		for _, e := range m.Network {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
+
+func (m *MemoryStat) GetSwap() *MemoryEntry {
+	if m != nil {
+		return m.Swap
 	}
-	return n
+	return nil
 }
 
-func (m *HugetlbStat) Size() (n int) {
-	var l int
-	_ = l
-	if m.Usage != 0 {
-		n += 1 + sovMetrics(uint64(m.Usage))
-	}
-	if m.Max != 0 {
-		n += 1 + sovMetrics(uint64(m.Max))
-	}
-	if m.Failcnt != 0 {
-		n += 1 + sovMetrics(uint64(m.Failcnt))
-	}
-	l = len(m.Pagesize)
-	if l > 0 {
-		n += 1 + l + sovMetrics(uint64(l))
+func (m *MemoryStat) GetKernel() *MemoryEntry {
+	if m != nil {
+		return m.Kernel
 	}
-	return n
+	return nil
 }
 
-func (m *PidsStat) Size() (n int) {
-	var l int
-	_ = l
-	if m.Current != 0 {
-		n += 1 + sovMetrics(uint64(m.Current))
-	}
-	if m.Limit != 0 {
-		n += 1 + sovMetrics(uint64(m.Limit))
+func (m *MemoryStat) GetKernelTCP() *MemoryEntry {
+	if m != nil {
+		return m.KernelTCP
 	}
-	return n
+	return nil
 }
 
-func (m *CPUStat) Size() (n int) {
-	var l int
-	_ = l
-	if m.Usage != nil {
-		l = m.Usage.Size()
-		n += 1 + l + sovMetrics(uint64(l))
-	}
-	if m.Throttling != nil {
-		l = m.Throttling.Size()
-		n += 1 + l + sovMetrics(uint64(l))
-	}
-	return n
+type MemoryEntry struct {
+	Limit   uint64 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
+	Usage   uint64 `protobuf:"varint,2,opt,name=usage,proto3" json:"usage,omitempty"`
+	Max     uint64 `protobuf:"varint,3,opt,name=max,proto3" json:"max,omitempty"`
+	Failcnt uint64 `protobuf:"varint,4,opt,name=failcnt,proto3" json:"failcnt,omitempty"`
 }
 
-func (m *CPUUsage) Size() (n int) {
-	var l int
-	_ = l
-	if m.Total != 0 {
-		n += 1 + sovMetrics(uint64(m.Total))
-	}
-	if m.Kernel != 0 {
-		n += 1 + sovMetrics(uint64(m.Kernel))
-	}
-	if m.User != 0 {
-		n += 1 + sovMetrics(uint64(m.User))
-	}
-	if len(m.PerCPU) > 0 {
-		l = 0
-		for _, e := range m.PerCPU {
-			l += sovMetrics(uint64(e))
-		}
-		n += 1 + sovMetrics(uint64(l)) + l
+func (m *MemoryEntry) Reset()                    { *m = MemoryEntry{} }
+func (m *MemoryEntry) String() string            { return proto.CompactTextString(m) }
+func (*MemoryEntry) ProtoMessage()               {}
+func (*MemoryEntry) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{7} }
+
+func (m *MemoryEntry) GetLimit() uint64 {
+	if m != nil {
+		return m.Limit
 	}
-	return n
+	return 0
 }
 
-func (m *Throttle) Size() (n int) {
-	var l int
-	_ = l
-	if m.Periods != 0 {
-		n += 1 + sovMetrics(uint64(m.Periods))
-	}
-	if m.ThrottledPeriods != 0 {
-		n += 1 + sovMetrics(uint64(m.ThrottledPeriods))
-	}
-	if m.ThrottledTime != 0 {
-		n += 1 + sovMetrics(uint64(m.ThrottledTime))
+func (m *MemoryEntry) GetUsage() uint64 {
+	if m != nil {
+		return m.Usage
 	}
-	return n
+	return 0
 }
 
-func (m *MemoryStat) Size() (n int) {
-	var l int
-	_ = l
-	if m.Cache != 0 {
-		n += 1 + sovMetrics(uint64(m.Cache))
-	}
-	if m.RSS != 0 {
-		n += 1 + sovMetrics(uint64(m.RSS))
-	}
-	if m.RSSHuge != 0 {
-		n += 1 + sovMetrics(uint64(m.RSSHuge))
-	}
-	if m.MappedFile != 0 {
-		n += 1 + sovMetrics(uint64(m.MappedFile))
-	}
-	if m.Dirty != 0 {
-		n += 1 + sovMetrics(uint64(m.Dirty))
-	}
-	if m.Writeback != 0 {
-		n += 1 + sovMetrics(uint64(m.Writeback))
-	}
-	if m.PgPgIn != 0 {
-		n += 1 + sovMetrics(uint64(m.PgPgIn))
-	}
-	if m.PgPgOut != 0 {
-		n += 1 + sovMetrics(uint64(m.PgPgOut))
-	}
-	if m.PgFault != 0 {
-		n += 1 + sovMetrics(uint64(m.PgFault))
-	}
-	if m.PgMajFault != 0 {
-		n += 1 + sovMetrics(uint64(m.PgMajFault))
-	}
-	if m.InactiveAnon != 0 {
-		n += 1 + sovMetrics(uint64(m.InactiveAnon))
-	}
-	if m.ActiveAnon != 0 {
-		n += 1 + sovMetrics(uint64(m.ActiveAnon))
-	}
-	if m.InactiveFile != 0 {
-		n += 1 + sovMetrics(uint64(m.InactiveFile))
-	}
-	if m.ActiveFile != 0 {
-		n += 1 + sovMetrics(uint64(m.ActiveFile))
-	}
-	if m.Unevictable != 0 {
-		n += 1 + sovMetrics(uint64(m.Unevictable))
-	}
-	if m.HierarchicalMemoryLimit != 0 {
-		n += 2 + sovMetrics(uint64(m.HierarchicalMemoryLimit))
-	}
-	if m.HierarchicalSwapLimit != 0 {
-		n += 2 + sovMetrics(uint64(m.HierarchicalSwapLimit))
-	}
-	if m.TotalCache != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalCache))
+func (m *MemoryEntry) GetMax() uint64 {
+	if m != nil {
+		return m.Max
 	}
-	if m.TotalRSS != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalRSS))
-	}
-	if m.TotalRSSHuge != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalRSSHuge))
-	}
-	if m.TotalMappedFile != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalMappedFile))
-	}
-	if m.TotalDirty != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalDirty))
-	}
-	if m.TotalWriteback != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalWriteback))
-	}
-	if m.TotalPgPgIn != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalPgPgIn))
-	}
-	if m.TotalPgPgOut != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalPgPgOut))
-	}
-	if m.TotalPgFault != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalPgFault))
-	}
-	if m.TotalPgMajFault != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalPgMajFault))
-	}
-	if m.TotalInactiveAnon != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalInactiveAnon))
-	}
-	if m.TotalActiveAnon != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalActiveAnon))
-	}
-	if m.TotalInactiveFile != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalInactiveFile))
-	}
-	if m.TotalActiveFile != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalActiveFile))
-	}
-	if m.TotalUnevictable != 0 {
-		n += 2 + sovMetrics(uint64(m.TotalUnevictable))
-	}
-	if m.Usage != nil {
-		l = m.Usage.Size()
-		n += 2 + l + sovMetrics(uint64(l))
-	}
-	if m.Swap != nil {
-		l = m.Swap.Size()
-		n += 2 + l + sovMetrics(uint64(l))
-	}
-	if m.Kernel != nil {
-		l = m.Kernel.Size()
-		n += 2 + l + sovMetrics(uint64(l))
-	}
-	if m.KernelTCP != nil {
-		l = m.KernelTCP.Size()
-		n += 2 + l + sovMetrics(uint64(l))
-	}
-	return n
+	return 0
 }
 
-func (m *MemoryEntry) Size() (n int) {
-	var l int
-	_ = l
-	if m.Limit != 0 {
-		n += 1 + sovMetrics(uint64(m.Limit))
-	}
-	if m.Usage != 0 {
-		n += 1 + sovMetrics(uint64(m.Usage))
+func (m *MemoryEntry) GetFailcnt() uint64 {
+	if m != nil {
+		return m.Failcnt
 	}
-	if m.Max != 0 {
-		n += 1 + sovMetrics(uint64(m.Max))
-	}
-	if m.Failcnt != 0 {
-		n += 1 + sovMetrics(uint64(m.Failcnt))
-	}
-	return n
+	return 0
 }
 
-func (m *BlkIOStat) Size() (n int) {
-	var l int
-	_ = l
-	if len(m.IoServiceBytesRecursive) > 0 {
-		for _, e := range m.IoServiceBytesRecursive {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
-	}
-	if len(m.IoServicedRecursive) > 0 {
-		for _, e := range m.IoServicedRecursive {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
-	}
-	if len(m.IoQueuedRecursive) > 0 {
-		for _, e := range m.IoQueuedRecursive {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
-	}
-	if len(m.IoServiceTimeRecursive) > 0 {
-		for _, e := range m.IoServiceTimeRecursive {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
-	}
-	if len(m.IoWaitTimeRecursive) > 0 {
-		for _, e := range m.IoWaitTimeRecursive {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
-	}
-	if len(m.IoMergedRecursive) > 0 {
-		for _, e := range m.IoMergedRecursive {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
-	}
-	if len(m.IoTimeRecursive) > 0 {
-		for _, e := range m.IoTimeRecursive {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
-	}
-	if len(m.SectorsRecursive) > 0 {
-		for _, e := range m.SectorsRecursive {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
-	}
-	return n
+type BlkIOStat struct {
+	IoServiceBytesRecursive []*BlkIOEntry `protobuf:"bytes,1,rep,name=io_service_bytes_recursive,json=ioServiceBytesRecursive" json:"io_service_bytes_recursive,omitempty"`
+	IoServicedRecursive     []*BlkIOEntry `protobuf:"bytes,2,rep,name=io_serviced_recursive,json=ioServicedRecursive" json:"io_serviced_recursive,omitempty"`
+	IoQueuedRecursive       []*BlkIOEntry `protobuf:"bytes,3,rep,name=io_queued_recursive,json=ioQueuedRecursive" json:"io_queued_recursive,omitempty"`
+	IoServiceTimeRecursive  []*BlkIOEntry `protobuf:"bytes,4,rep,name=io_service_time_recursive,json=ioServiceTimeRecursive" json:"io_service_time_recursive,omitempty"`
+	IoWaitTimeRecursive     []*BlkIOEntry `protobuf:"bytes,5,rep,name=io_wait_time_recursive,json=ioWaitTimeRecursive" json:"io_wait_time_recursive,omitempty"`
+	IoMergedRecursive       []*BlkIOEntry `protobuf:"bytes,6,rep,name=io_merged_recursive,json=ioMergedRecursive" json:"io_merged_recursive,omitempty"`
+	IoTimeRecursive         []*BlkIOEntry `protobuf:"bytes,7,rep,name=io_time_recursive,json=ioTimeRecursive" json:"io_time_recursive,omitempty"`
+	SectorsRecursive        []*BlkIOEntry `protobuf:"bytes,8,rep,name=sectors_recursive,json=sectorsRecursive" json:"sectors_recursive,omitempty"`
 }
 
-func (m *BlkIOEntry) Size() (n int) {
-	var l int
-	_ = l
-	l = len(m.Op)
-	if l > 0 {
-		n += 1 + l + sovMetrics(uint64(l))
-	}
-	l = len(m.Device)
-	if l > 0 {
-		n += 1 + l + sovMetrics(uint64(l))
-	}
-	if m.Major != 0 {
-		n += 1 + sovMetrics(uint64(m.Major))
-	}
-	if m.Minor != 0 {
-		n += 1 + sovMetrics(uint64(m.Minor))
-	}
-	if m.Value != 0 {
-		n += 1 + sovMetrics(uint64(m.Value))
+func (m *BlkIOStat) Reset()                    { *m = BlkIOStat{} }
+func (m *BlkIOStat) String() string            { return proto.CompactTextString(m) }
+func (*BlkIOStat) ProtoMessage()               {}
+func (*BlkIOStat) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{8} }
+
+func (m *BlkIOStat) GetIoServiceBytesRecursive() []*BlkIOEntry {
+	if m != nil {
+		return m.IoServiceBytesRecursive
 	}
-	return n
+	return nil
 }
 
-func (m *RdmaStat) Size() (n int) {
-	var l int
-	_ = l
-	if len(m.Current) > 0 {
-		for _, e := range m.Current {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
+func (m *BlkIOStat) GetIoServicedRecursive() []*BlkIOEntry {
+	if m != nil {
+		return m.IoServicedRecursive
 	}
-	if len(m.Limit) > 0 {
-		for _, e := range m.Limit {
-			l = e.Size()
-			n += 1 + l + sovMetrics(uint64(l))
-		}
-	}
-	return n
+	return nil
 }
 
-func (m *RdmaEntry) Size() (n int) {
-	var l int
-	_ = l
-	l = len(m.Device)
-	if l > 0 {
-		n += 1 + l + sovMetrics(uint64(l))
-	}
-	if m.HcaHandles != 0 {
-		n += 1 + sovMetrics(uint64(m.HcaHandles))
+func (m *BlkIOStat) GetIoQueuedRecursive() []*BlkIOEntry {
+	if m != nil {
+		return m.IoQueuedRecursive
 	}
-	if m.HcaObjects != 0 {
-		n += 1 + sovMetrics(uint64(m.HcaObjects))
-	}
-	return n
+	return nil
 }
 
-func (m *NetworkStat) Size() (n int) {
-	var l int
-	_ = l
-	l = len(m.Name)
-	if l > 0 {
-		n += 1 + l + sovMetrics(uint64(l))
-	}
-	if m.RxBytes != 0 {
-		n += 1 + sovMetrics(uint64(m.RxBytes))
-	}
-	if m.RxPackets != 0 {
-		n += 1 + sovMetrics(uint64(m.RxPackets))
-	}
-	if m.RxErrors != 0 {
-		n += 1 + sovMetrics(uint64(m.RxErrors))
-	}
-	if m.RxDropped != 0 {
-		n += 1 + sovMetrics(uint64(m.RxDropped))
-	}
-	if m.TxBytes != 0 {
-		n += 1 + sovMetrics(uint64(m.TxBytes))
+func (m *BlkIOStat) GetIoServiceTimeRecursive() []*BlkIOEntry {
+	if m != nil {
+		return m.IoServiceTimeRecursive
 	}
-	if m.TxPackets != 0 {
-		n += 1 + sovMetrics(uint64(m.TxPackets))
-	}
-	if m.TxErrors != 0 {
-		n += 1 + sovMetrics(uint64(m.TxErrors))
-	}
-	if m.TxDropped != 0 {
-		n += 1 + sovMetrics(uint64(m.TxDropped))
-	}
-	return n
+	return nil
 }
 
-func sovMetrics(x uint64) (n int) {
-	for {
-		n++
-		x >>= 7
-		if x == 0 {
-			break
-		}
+func (m *BlkIOStat) GetIoWaitTimeRecursive() []*BlkIOEntry {
+	if m != nil {
+		return m.IoWaitTimeRecursive
 	}
-	return n
-}
-func sozMetrics(x uint64) (n int) {
-	return sovMetrics(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+	return nil
 }
-func (this *Metrics) String() string {
-	if this == nil {
-		return "nil"
+
+func (m *BlkIOStat) GetIoMergedRecursive() []*BlkIOEntry {
+	if m != nil {
+		return m.IoMergedRecursive
 	}
-	s := strings.Join([]string{`&Metrics{`,
-		`Hugetlb:` + strings.Replace(fmt.Sprintf("%v", this.Hugetlb), "HugetlbStat", "HugetlbStat", 1) + `,`,
-		`Pids:` + strings.Replace(fmt.Sprintf("%v", this.Pids), "PidsStat", "PidsStat", 1) + `,`,
-		`CPU:` + strings.Replace(fmt.Sprintf("%v", this.CPU), "CPUStat", "CPUStat", 1) + `,`,
-		`Memory:` + strings.Replace(fmt.Sprintf("%v", this.Memory), "MemoryStat", "MemoryStat", 1) + `,`,
-		`Blkio:` + strings.Replace(fmt.Sprintf("%v", this.Blkio), "BlkIOStat", "BlkIOStat", 1) + `,`,
-		`Rdma:` + strings.Replace(fmt.Sprintf("%v", this.Rdma), "RdmaStat", "RdmaStat", 1) + `,`,
-		`Network:` + strings.Replace(fmt.Sprintf("%v", this.Network), "NetworkStat", "NetworkStat", 1) + `,`,
-		`}`,
-	}, "")
-	return s
+	return nil
 }
-func (this *HugetlbStat) String() string {
-	if this == nil {
-		return "nil"
+
+func (m *BlkIOStat) GetIoTimeRecursive() []*BlkIOEntry {
+	if m != nil {
+		return m.IoTimeRecursive
 	}
-	s := strings.Join([]string{`&HugetlbStat{`,
-		`Usage:` + fmt.Sprintf("%v", this.Usage) + `,`,
-		`Max:` + fmt.Sprintf("%v", this.Max) + `,`,
-		`Failcnt:` + fmt.Sprintf("%v", this.Failcnt) + `,`,
-		`Pagesize:` + fmt.Sprintf("%v", this.Pagesize) + `,`,
-		`}`,
-	}, "")
-	return s
+	return nil
 }
-func (this *PidsStat) String() string {
-	if this == nil {
-		return "nil"
+
+func (m *BlkIOStat) GetSectorsRecursive() []*BlkIOEntry {
+	if m != nil {
+		return m.SectorsRecursive
 	}
-	s := strings.Join([]string{`&PidsStat{`,
-		`Current:` + fmt.Sprintf("%v", this.Current) + `,`,
-		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
-		`}`,
-	}, "")
-	return s
+	return nil
 }
-func (this *CPUStat) String() string {
-	if this == nil {
-		return "nil"
-	}
-	s := strings.Join([]string{`&CPUStat{`,
-		`Usage:` + strings.Replace(fmt.Sprintf("%v", this.Usage), "CPUUsage", "CPUUsage", 1) + `,`,
-		`Throttling:` + strings.Replace(fmt.Sprintf("%v", this.Throttling), "Throttle", "Throttle", 1) + `,`,
-		`}`,
-	}, "")
-	return s
+
+type BlkIOEntry struct {
+	Op     string `protobuf:"bytes,1,opt,name=op,proto3" json:"op,omitempty"`
+	Device string `protobuf:"bytes,2,opt,name=device,proto3" json:"device,omitempty"`
+	Major  uint64 `protobuf:"varint,3,opt,name=major,proto3" json:"major,omitempty"`
+	Minor  uint64 `protobuf:"varint,4,opt,name=minor,proto3" json:"minor,omitempty"`
+	Value  uint64 `protobuf:"varint,5,opt,name=value,proto3" json:"value,omitempty"`
 }
-func (this *CPUUsage) String() string {
-	if this == nil {
-		return "nil"
+
+func (m *BlkIOEntry) Reset()                    { *m = BlkIOEntry{} }
+func (m *BlkIOEntry) String() string            { return proto.CompactTextString(m) }
+func (*BlkIOEntry) ProtoMessage()               {}
+func (*BlkIOEntry) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{9} }
+
+func (m *BlkIOEntry) GetOp() string {
+	if m != nil {
+		return m.Op
 	}
-	s := strings.Join([]string{`&CPUUsage{`,
-		`Total:` + fmt.Sprintf("%v", this.Total) + `,`,
-		`Kernel:` + fmt.Sprintf("%v", this.Kernel) + `,`,
-		`User:` + fmt.Sprintf("%v", this.User) + `,`,
-		`PerCPU:` + fmt.Sprintf("%v", this.PerCPU) + `,`,
-		`}`,
-	}, "")
-	return s
+	return ""
 }
-func (this *Throttle) String() string {
-	if this == nil {
-		return "nil"
+
+func (m *BlkIOEntry) GetDevice() string {
+	if m != nil {
+		return m.Device
 	}
-	s := strings.Join([]string{`&Throttle{`,
-		`Periods:` + fmt.Sprintf("%v", this.Periods) + `,`,
-		`ThrottledPeriods:` + fmt.Sprintf("%v", this.ThrottledPeriods) + `,`,
-		`ThrottledTime:` + fmt.Sprintf("%v", this.ThrottledTime) + `,`,
-		`}`,
-	}, "")
-	return s
+	return ""
 }
-func (this *MemoryStat) String() string {
-	if this == nil {
-		return "nil"
+
+func (m *BlkIOEntry) GetMajor() uint64 {
+	if m != nil {
+		return m.Major
 	}
-	s := strings.Join([]string{`&MemoryStat{`,
-		`Cache:` + fmt.Sprintf("%v", this.Cache) + `,`,
-		`RSS:` + fmt.Sprintf("%v", this.RSS) + `,`,
-		`RSSHuge:` + fmt.Sprintf("%v", this.RSSHuge) + `,`,
-		`MappedFile:` + fmt.Sprintf("%v", this.MappedFile) + `,`,
-		`Dirty:` + fmt.Sprintf("%v", this.Dirty) + `,`,
-		`Writeback:` + fmt.Sprintf("%v", this.Writeback) + `,`,
-		`PgPgIn:` + fmt.Sprintf("%v", this.PgPgIn) + `,`,
-		`PgPgOut:` + fmt.Sprintf("%v", this.PgPgOut) + `,`,
-		`PgFault:` + fmt.Sprintf("%v", this.PgFault) + `,`,
-		`PgMajFault:` + fmt.Sprintf("%v", this.PgMajFault) + `,`,
-		`InactiveAnon:` + fmt.Sprintf("%v", this.InactiveAnon) + `,`,
-		`ActiveAnon:` + fmt.Sprintf("%v", this.ActiveAnon) + `,`,
-		`InactiveFile:` + fmt.Sprintf("%v", this.InactiveFile) + `,`,
-		`ActiveFile:` + fmt.Sprintf("%v", this.ActiveFile) + `,`,
-		`Unevictable:` + fmt.Sprintf("%v", this.Unevictable) + `,`,
-		`HierarchicalMemoryLimit:` + fmt.Sprintf("%v", this.HierarchicalMemoryLimit) + `,`,
-		`HierarchicalSwapLimit:` + fmt.Sprintf("%v", this.HierarchicalSwapLimit) + `,`,
-		`TotalCache:` + fmt.Sprintf("%v", this.TotalCache) + `,`,
-		`TotalRSS:` + fmt.Sprintf("%v", this.TotalRSS) + `,`,
-		`TotalRSSHuge:` + fmt.Sprintf("%v", this.TotalRSSHuge) + `,`,
-		`TotalMappedFile:` + fmt.Sprintf("%v", this.TotalMappedFile) + `,`,
-		`TotalDirty:` + fmt.Sprintf("%v", this.TotalDirty) + `,`,
-		`TotalWriteback:` + fmt.Sprintf("%v", this.TotalWriteback) + `,`,
-		`TotalPgPgIn:` + fmt.Sprintf("%v", this.TotalPgPgIn) + `,`,
-		`TotalPgPgOut:` + fmt.Sprintf("%v", this.TotalPgPgOut) + `,`,
-		`TotalPgFault:` + fmt.Sprintf("%v", this.TotalPgFault) + `,`,
-		`TotalPgMajFault:` + fmt.Sprintf("%v", this.TotalPgMajFault) + `,`,
-		`TotalInactiveAnon:` + fmt.Sprintf("%v", this.TotalInactiveAnon) + `,`,
-		`TotalActiveAnon:` + fmt.Sprintf("%v", this.TotalActiveAnon) + `,`,
-		`TotalInactiveFile:` + fmt.Sprintf("%v", this.TotalInactiveFile) + `,`,
-		`TotalActiveFile:` + fmt.Sprintf("%v", this.TotalActiveFile) + `,`,
-		`TotalUnevictable:` + fmt.Sprintf("%v", this.TotalUnevictable) + `,`,
-		`Usage:` + strings.Replace(fmt.Sprintf("%v", this.Usage), "MemoryEntry", "MemoryEntry", 1) + `,`,
-		`Swap:` + strings.Replace(fmt.Sprintf("%v", this.Swap), "MemoryEntry", "MemoryEntry", 1) + `,`,
-		`Kernel:` + strings.Replace(fmt.Sprintf("%v", this.Kernel), "MemoryEntry", "MemoryEntry", 1) + `,`,
-		`KernelTCP:` + strings.Replace(fmt.Sprintf("%v", this.KernelTCP), "MemoryEntry", "MemoryEntry", 1) + `,`,
-		`}`,
-	}, "")
-	return s
+	return 0
 }
-func (this *MemoryEntry) String() string {
-	if this == nil {
-		return "nil"
+
+func (m *BlkIOEntry) GetMinor() uint64 {
+	if m != nil {
+		return m.Minor
 	}
-	s := strings.Join([]string{`&MemoryEntry{`,
-		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
-		`Usage:` + fmt.Sprintf("%v", this.Usage) + `,`,
-		`Max:` + fmt.Sprintf("%v", this.Max) + `,`,
-		`Failcnt:` + fmt.Sprintf("%v", this.Failcnt) + `,`,
-		`}`,
-	}, "")
-	return s
+	return 0
 }
-func (this *BlkIOStat) String() string {
-	if this == nil {
-		return "nil"
+
+func (m *BlkIOEntry) GetValue() uint64 {
+	if m != nil {
+		return m.Value
 	}
-	s := strings.Join([]string{`&BlkIOStat{`,
-		`IoServiceBytesRecursive:` + strings.Replace(fmt.Sprintf("%v", this.IoServiceBytesRecursive), "BlkIOEntry", "BlkIOEntry", 1) + `,`,
-		`IoServicedRecursive:` + strings.Replace(fmt.Sprintf("%v", this.IoServicedRecursive), "BlkIOEntry", "BlkIOEntry", 1) + `,`,
-		`IoQueuedRecursive:` + strings.Replace(fmt.Sprintf("%v", this.IoQueuedRecursive), "BlkIOEntry", "BlkIOEntry", 1) + `,`,
-		`IoServiceTimeRecursive:` + strings.Replace(fmt.Sprintf("%v", this.IoServiceTimeRecursive), "BlkIOEntry", "BlkIOEntry", 1) + `,`,
-		`IoWaitTimeRecursive:` + strings.Replace(fmt.Sprintf("%v", this.IoWaitTimeRecursive), "BlkIOEntry", "BlkIOEntry", 1) + `,`,
-		`IoMergedRecursive:` + strings.Replace(fmt.Sprintf("%v", this.IoMergedRecursive), "BlkIOEntry", "BlkIOEntry", 1) + `,`,
-		`IoTimeRecursive:` + strings.Replace(fmt.Sprintf("%v", this.IoTimeRecursive), "BlkIOEntry", "BlkIOEntry", 1) + `,`,
-		`SectorsRecursive:` + strings.Replace(fmt.Sprintf("%v", this.SectorsRecursive), "BlkIOEntry", "BlkIOEntry", 1) + `,`,
-		`}`,
-	}, "")
-	return s
+	return 0
 }
-func (this *BlkIOEntry) String() string {
-	if this == nil {
-		return "nil"
-	}
-	s := strings.Join([]string{`&BlkIOEntry{`,
-		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
-		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
-		`Major:` + fmt.Sprintf("%v", this.Major) + `,`,
-		`Minor:` + fmt.Sprintf("%v", this.Minor) + `,`,
-		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
-		`}`,
-	}, "")
-	return s
+
+type RdmaStat struct {
+	Current []*RdmaEntry `protobuf:"bytes,1,rep,name=current" json:"current,omitempty"`
+	Limit   []*RdmaEntry `protobuf:"bytes,2,rep,name=limit" json:"limit,omitempty"`
 }
-func (this *RdmaStat) String() string {
-	if this == nil {
-		return "nil"
+
+func (m *RdmaStat) Reset()                    { *m = RdmaStat{} }
+func (m *RdmaStat) String() string            { return proto.CompactTextString(m) }
+func (*RdmaStat) ProtoMessage()               {}
+func (*RdmaStat) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{10} }
+
+func (m *RdmaStat) GetCurrent() []*RdmaEntry {
+	if m != nil {
+		return m.Current
 	}
-	s := strings.Join([]string{`&RdmaStat{`,
-		`Current:` + strings.Replace(fmt.Sprintf("%v", this.Current), "RdmaEntry", "RdmaEntry", 1) + `,`,
-		`Limit:` + strings.Replace(fmt.Sprintf("%v", this.Limit), "RdmaEntry", "RdmaEntry", 1) + `,`,
-		`}`,
-	}, "")
-	return s
+	return nil
 }
-func (this *RdmaEntry) String() string {
-	if this == nil {
-		return "nil"
+
+func (m *RdmaStat) GetLimit() []*RdmaEntry {
+	if m != nil {
+		return m.Limit
 	}
-	s := strings.Join([]string{`&RdmaEntry{`,
-		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
-		`HcaHandles:` + fmt.Sprintf("%v", this.HcaHandles) + `,`,
-		`HcaObjects:` + fmt.Sprintf("%v", this.HcaObjects) + `,`,
-		`}`,
-	}, "")
-	return s
+	return nil
 }
-func (this *NetworkStat) String() string {
-	if this == nil {
-		return "nil"
-	}
-	s := strings.Join([]string{`&NetworkStat{`,
-		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
-		`RxBytes:` + fmt.Sprintf("%v", this.RxBytes) + `,`,
-		`RxPackets:` + fmt.Sprintf("%v", this.RxPackets) + `,`,
-		`RxErrors:` + fmt.Sprintf("%v", this.RxErrors) + `,`,
-		`RxDropped:` + fmt.Sprintf("%v", this.RxDropped) + `,`,
-		`TxBytes:` + fmt.Sprintf("%v", this.TxBytes) + `,`,
-		`TxPackets:` + fmt.Sprintf("%v", this.TxPackets) + `,`,
-		`TxErrors:` + fmt.Sprintf("%v", this.TxErrors) + `,`,
-		`TxDropped:` + fmt.Sprintf("%v", this.TxDropped) + `,`,
-		`}`,
-	}, "")
-	return s
+
+type RdmaEntry struct {
+	Device     string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
+	HcaHandles uint32 `protobuf:"varint,2,opt,name=hca_handles,json=hcaHandles,proto3" json:"hca_handles,omitempty"`
+	HcaObjects uint32 `protobuf:"varint,3,opt,name=hca_objects,json=hcaObjects,proto3" json:"hca_objects,omitempty"`
 }
-func valueToStringMetrics(v interface{}) string {
-	rv := reflect.ValueOf(v)
-	if rv.IsNil() {
-		return "nil"
+
+func (m *RdmaEntry) Reset()                    { *m = RdmaEntry{} }
+func (m *RdmaEntry) String() string            { return proto.CompactTextString(m) }
+func (*RdmaEntry) ProtoMessage()               {}
+func (*RdmaEntry) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{11} }
+
+func (m *RdmaEntry) GetDevice() string {
+	if m != nil {
+		return m.Device
 	}
-	pv := reflect.Indirect(rv).Interface()
-	return fmt.Sprintf("*%v", pv)
+	return ""
 }
-func (m *Metrics) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Hugetlb", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Hugetlb = append(m.Hugetlb, &HugetlbStat{})
-			if err := m.Hugetlb[len(m.Hugetlb)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Pids", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Pids == nil {
-				m.Pids = &PidsStat{}
-			}
-			if err := m.Pids.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field CPU", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.CPU == nil {
-				m.CPU = &CPUStat{}
-			}
-			if err := m.CPU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 4:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Memory == nil {
-				m.Memory = &MemoryStat{}
-			}
-			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 5:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Blkio", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Blkio == nil {
-				m.Blkio = &BlkIOStat{}
-			}
-			if err := m.Blkio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 6:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Rdma", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Rdma == nil {
-				m.Rdma = &RdmaStat{}
-			}
-			if err := m.Rdma.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 7:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Network = append(m.Network, &NetworkStat{})
-			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+func (m *RdmaEntry) GetHcaHandles() uint32 {
+	if m != nil {
+		return m.HcaHandles
 	}
-	return nil
+	return 0
 }
-func (m *HugetlbStat) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: HugetlbStat: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HugetlbStat: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
-			}
-			m.Usage = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Usage |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
-			}
-			m.Max = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Max |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Failcnt", wireType)
-			}
-			m.Failcnt = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Failcnt |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 4:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Pagesize", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Pagesize = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+func (m *RdmaEntry) GetHcaObjects() uint32 {
+	if m != nil {
+		return m.HcaObjects
 	}
-	return nil
+	return 0
 }
-func (m *PidsStat) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: PidsStat: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: PidsStat: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
-			}
-			m.Current = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Current |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
-			}
-			m.Limit = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Limit |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
+type NetworkStat struct {
+	Name      string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	RxBytes   uint64 `protobuf:"varint,2,opt,name=rx_bytes,json=rxBytes,proto3" json:"rx_bytes,omitempty"`
+	RxPackets uint64 `protobuf:"varint,3,opt,name=rx_packets,json=rxPackets,proto3" json:"rx_packets,omitempty"`
+	RxErrors  uint64 `protobuf:"varint,4,opt,name=rx_errors,json=rxErrors,proto3" json:"rx_errors,omitempty"`
+	RxDropped uint64 `protobuf:"varint,5,opt,name=rx_dropped,json=rxDropped,proto3" json:"rx_dropped,omitempty"`
+	TxBytes   uint64 `protobuf:"varint,6,opt,name=tx_bytes,json=txBytes,proto3" json:"tx_bytes,omitempty"`
+	TxPackets uint64 `protobuf:"varint,7,opt,name=tx_packets,json=txPackets,proto3" json:"tx_packets,omitempty"`
+	TxErrors  uint64 `protobuf:"varint,8,opt,name=tx_errors,json=txErrors,proto3" json:"tx_errors,omitempty"`
+	TxDropped uint64 `protobuf:"varint,9,opt,name=tx_dropped,json=txDropped,proto3" json:"tx_dropped,omitempty"`
 }
-func (m *CPUStat) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: CPUStat: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: CPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Usage == nil {
-				m.Usage = &CPUUsage{}
-			}
-			if err := m.Usage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Throttling", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Throttling == nil {
-				m.Throttling = &Throttle{}
-			}
-			if err := m.Throttling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+func (m *NetworkStat) Reset()                    { *m = NetworkStat{} }
+func (m *NetworkStat) String() string            { return proto.CompactTextString(m) }
+func (*NetworkStat) ProtoMessage()               {}
+func (*NetworkStat) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{12} }
+
+func (m *NetworkStat) GetName() string {
+	if m != nil {
+		return m.Name
 	}
-	return nil
+	return ""
 }
-func (m *CPUUsage) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: CPUUsage: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: CPUUsage: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
-			}
-			m.Total = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Total |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Kernel", wireType)
-			}
-			m.Kernel = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Kernel |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
-			}
-			m.User = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.User |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 4:
-			if wireType == 0 {
-				var v uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowMetrics
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					v |= (uint64(b) & 0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				m.PerCPU = append(m.PerCPU, v)
-			} else if wireType == 2 {
-				var packedLen int
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowMetrics
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					packedLen |= (int(b) & 0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				if packedLen < 0 {
-					return ErrInvalidLengthMetrics
-				}
-				postIndex := iNdEx + packedLen
-				if postIndex > l {
-					return io.ErrUnexpectedEOF
-				}
-				for iNdEx < postIndex {
-					var v uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowMetrics
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						v |= (uint64(b) & 0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					m.PerCPU = append(m.PerCPU, v)
-				}
-			} else {
-				return fmt.Errorf("proto: wrong wireType = %d for field PerCPU", wireType)
-			}
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+func (m *NetworkStat) GetRxBytes() uint64 {
+	if m != nil {
+		return m.RxBytes
 	}
-	return nil
+	return 0
 }
-func (m *Throttle) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: Throttle: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Throttle: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Periods", wireType)
-			}
-			m.Periods = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Periods |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ThrottledPeriods", wireType)
-			}
-			m.ThrottledPeriods = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.ThrottledPeriods |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ThrottledTime", wireType)
-			}
-			m.ThrottledTime = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.ThrottledTime |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+func (m *NetworkStat) GetRxPackets() uint64 {
+	if m != nil {
+		return m.RxPackets
 	}
-	return nil
+	return 0
 }
-func (m *MemoryStat) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: MemoryStat: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: MemoryStat: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
-			}
-			m.Cache = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Cache |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RSS", wireType)
-			}
-			m.RSS = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.RSS |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RSSHuge", wireType)
-			}
-			m.RSSHuge = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.RSSHuge |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 4:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MappedFile", wireType)
-			}
-			m.MappedFile = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.MappedFile |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 5:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Dirty", wireType)
-			}
-			m.Dirty = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Dirty |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 6:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Writeback", wireType)
-			}
-			m.Writeback = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Writeback |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 7:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field PgPgIn", wireType)
-			}
-			m.PgPgIn = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.PgPgIn |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 8:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field PgPgOut", wireType)
-			}
-			m.PgPgOut = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.PgPgOut |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 9:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field PgFault", wireType)
-			}
-			m.PgFault = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.PgFault |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 10:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field PgMajFault", wireType)
-			}
-			m.PgMajFault = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.PgMajFault |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 11:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field InactiveAnon", wireType)
-			}
-			m.InactiveAnon = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.InactiveAnon |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 12:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ActiveAnon", wireType)
-			}
-			m.ActiveAnon = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.ActiveAnon |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 13:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field InactiveFile", wireType)
-			}
-			m.InactiveFile = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.InactiveFile |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 14:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ActiveFile", wireType)
-			}
-			m.ActiveFile = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.ActiveFile |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 15:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Unevictable", wireType)
-			}
-			m.Unevictable = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Unevictable |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 16:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HierarchicalMemoryLimit", wireType)
-			}
-			m.HierarchicalMemoryLimit = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.HierarchicalMemoryLimit |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 17:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HierarchicalSwapLimit", wireType)
-			}
-			m.HierarchicalSwapLimit = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.HierarchicalSwapLimit |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 18:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalCache", wireType)
-			}
-			m.TotalCache = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalCache |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 19:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalRSS", wireType)
-			}
-			m.TotalRSS = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalRSS |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 20:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalRSSHuge", wireType)
-			}
-			m.TotalRSSHuge = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalRSSHuge |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 21:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalMappedFile", wireType)
-			}
-			m.TotalMappedFile = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalMappedFile |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 22:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalDirty", wireType)
-			}
-			m.TotalDirty = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalDirty |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 23:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalWriteback", wireType)
-			}
-			m.TotalWriteback = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalWriteback |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 24:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalPgPgIn", wireType)
-			}
-			m.TotalPgPgIn = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalPgPgIn |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 25:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalPgPgOut", wireType)
-			}
-			m.TotalPgPgOut = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalPgPgOut |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 26:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalPgFault", wireType)
-			}
-			m.TotalPgFault = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalPgFault |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 27:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalPgMajFault", wireType)
-			}
-			m.TotalPgMajFault = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalPgMajFault |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 28:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalInactiveAnon", wireType)
-			}
-			m.TotalInactiveAnon = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalInactiveAnon |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 29:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalActiveAnon", wireType)
-			}
-			m.TotalActiveAnon = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalActiveAnon |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 30:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalInactiveFile", wireType)
-			}
-			m.TotalInactiveFile = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalInactiveFile |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 31:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalActiveFile", wireType)
-			}
-			m.TotalActiveFile = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalActiveFile |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 32:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TotalUnevictable", wireType)
-			}
-			m.TotalUnevictable = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TotalUnevictable |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 33:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Usage == nil {
-				m.Usage = &MemoryEntry{}
-			}
-			if err := m.Usage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 34:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Swap == nil {
-				m.Swap = &MemoryEntry{}
-			}
-			if err := m.Swap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 35:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Kernel", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Kernel == nil {
-				m.Kernel = &MemoryEntry{}
-			}
-			if err := m.Kernel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 36:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field KernelTCP", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.KernelTCP == nil {
-				m.KernelTCP = &MemoryEntry{}
-			}
-			if err := m.KernelTCP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+func (m *NetworkStat) GetRxErrors() uint64 {
+	if m != nil {
+		return m.RxErrors
 	}
-	return nil
+	return 0
 }
-func (m *MemoryEntry) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: MemoryEntry: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: MemoryEntry: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
-			}
-			m.Limit = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Limit |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
-			}
-			m.Usage = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Usage |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
-			}
-			m.Max = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Max |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 4:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Failcnt", wireType)
-			}
-			m.Failcnt = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Failcnt |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+func (m *NetworkStat) GetRxDropped() uint64 {
+	if m != nil {
+		return m.RxDropped
 	}
-	return nil
+	return 0
 }
-func (m *BlkIOStat) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: BlkIOStat: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: BlkIOStat: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field IoServiceBytesRecursive", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.IoServiceBytesRecursive = append(m.IoServiceBytesRecursive, &BlkIOEntry{})
-			if err := m.IoServiceBytesRecursive[len(m.IoServiceBytesRecursive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field IoServicedRecursive", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.IoServicedRecursive = append(m.IoServicedRecursive, &BlkIOEntry{})
-			if err := m.IoServicedRecursive[len(m.IoServicedRecursive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field IoQueuedRecursive", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.IoQueuedRecursive = append(m.IoQueuedRecursive, &BlkIOEntry{})
-			if err := m.IoQueuedRecursive[len(m.IoQueuedRecursive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 4:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field IoServiceTimeRecursive", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.IoServiceTimeRecursive = append(m.IoServiceTimeRecursive, &BlkIOEntry{})
-			if err := m.IoServiceTimeRecursive[len(m.IoServiceTimeRecursive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 5:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field IoWaitTimeRecursive", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.IoWaitTimeRecursive = append(m.IoWaitTimeRecursive, &BlkIOEntry{})
-			if err := m.IoWaitTimeRecursive[len(m.IoWaitTimeRecursive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 6:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field IoMergedRecursive", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.IoMergedRecursive = append(m.IoMergedRecursive, &BlkIOEntry{})
-			if err := m.IoMergedRecursive[len(m.IoMergedRecursive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 7:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field IoTimeRecursive", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.IoTimeRecursive = append(m.IoTimeRecursive, &BlkIOEntry{})
-			if err := m.IoTimeRecursive[len(m.IoTimeRecursive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 8:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SectorsRecursive", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.SectorsRecursive = append(m.SectorsRecursive, &BlkIOEntry{})
-			if err := m.SectorsRecursive[len(m.SectorsRecursive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+func (m *NetworkStat) GetTxBytes() uint64 {
+	if m != nil {
+		return m.TxBytes
 	}
-	return nil
+	return 0
 }
-func (m *BlkIOEntry) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: BlkIOEntry: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: BlkIOEntry: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Op = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Device = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
-			}
-			m.Major = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Major |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 4:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
-			}
-			m.Minor = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Minor |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 5:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
-			}
-			m.Value = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Value |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+func (m *NetworkStat) GetTxPackets() uint64 {
+	if m != nil {
+		return m.TxPackets
 	}
-	return nil
+	return 0
 }
-func (m *RdmaStat) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: RdmaStat: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: RdmaStat: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Current = append(m.Current, &RdmaEntry{})
-			if err := m.Current[len(m.Current)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + msglen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Limit = append(m.Limit, &RdmaEntry{})
-			if err := m.Limit[len(m.Limit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+func (m *NetworkStat) GetTxErrors() uint64 {
+	if m != nil {
+		return m.TxErrors
 	}
-	return nil
+	return 0
 }
-func (m *RdmaEntry) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: RdmaEntry: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: RdmaEntry: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Device = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HcaHandles", wireType)
-			}
-			m.HcaHandles = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.HcaHandles |= (uint32(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HcaObjects", wireType)
-			}
-			m.HcaObjects = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.HcaObjects |= (uint32(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+func (m *NetworkStat) GetTxDropped() uint64 {
+	if m != nil {
+		return m.TxDropped
 	}
-	return nil
+	return 0
 }
-func (m *NetworkStat) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: NetworkStat: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: NetworkStat: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Name = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RxBytes", wireType)
-			}
-			m.RxBytes = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.RxBytes |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RxPackets", wireType)
-			}
-			m.RxPackets = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.RxPackets |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 4:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RxErrors", wireType)
-			}
-			m.RxErrors = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.RxErrors |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 5:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RxDropped", wireType)
-			}
-			m.RxDropped = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.RxDropped |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 6:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TxBytes", wireType)
-			}
-			m.TxBytes = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TxBytes |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 7:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TxPackets", wireType)
-			}
-			m.TxPackets = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TxPackets |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 8:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TxErrors", wireType)
-			}
-			m.TxErrors = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TxErrors |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 9:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TxDropped", wireType)
-			}
-			m.TxDropped = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.TxDropped |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		default:
-			iNdEx = preIndex
-			skippy, err := skipMetrics(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if skippy < 0 {
-				return ErrInvalidLengthMetrics
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			iNdEx += skippy
-		}
-	}
 
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
+type FilesStat struct {
+	Usage uint64 `protobuf:"varint,1,opt,name=usage,proto3" json:"usage,omitempty"`
+	Limit uint64 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
+}
+
+func (m *FilesStat) Reset()                    { *m = FilesStat{} }
+func (m *FilesStat) String() string            { return proto.CompactTextString(m) }
+func (*FilesStat) ProtoMessage()               {}
+func (*FilesStat) Descriptor() ([]byte, []int) { return fileDescriptorMetrics, []int{13} }
+
+func (m *FilesStat) GetUsage() uint64 {
+	if m != nil {
+		return m.Usage
 	}
-	return nil
+	return 0
 }
-func skipMetrics(dAtA []byte) (n int, err error) {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return 0, ErrIntOverflowMetrics
-			}
-			if iNdEx >= l {
-				return 0, io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= (uint64(b) & 0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		wireType := int(wire & 0x7)
-		switch wireType {
-		case 0:
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return 0, ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return 0, io.ErrUnexpectedEOF
-				}
-				iNdEx++
-				if dAtA[iNdEx-1] < 0x80 {
-					break
-				}
-			}
-			return iNdEx, nil
-		case 1:
-			iNdEx += 8
-			return iNdEx, nil
-		case 2:
-			var length int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return 0, ErrIntOverflowMetrics
-				}
-				if iNdEx >= l {
-					return 0, io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				length |= (int(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			iNdEx += length
-			if length < 0 {
-				return 0, ErrInvalidLengthMetrics
-			}
-			return iNdEx, nil
-		case 3:
-			for {
-				var innerWire uint64
-				var start int = iNdEx
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return 0, ErrIntOverflowMetrics
-					}
-					if iNdEx >= l {
-						return 0, io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					innerWire |= (uint64(b) & 0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				innerWireType := int(innerWire & 0x7)
-				if innerWireType == 4 {
-					break
-				}
-				next, err := skipMetrics(dAtA[start:])
-				if err != nil {
-					return 0, err
-				}
-				iNdEx = start + next
-			}
-			return iNdEx, nil
-		case 4:
-			return iNdEx, nil
-		case 5:
-			iNdEx += 4
-			return iNdEx, nil
-		default:
-			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
-		}
+
+func (m *FilesStat) GetLimit() uint64 {
+	if m != nil {
+		return m.Limit
 	}
-	panic("unreachable")
+	return 0
 }
 
-var (
-	ErrInvalidLengthMetrics = fmt.Errorf("proto: negative length found during unmarshaling")
-	ErrIntOverflowMetrics   = fmt.Errorf("proto: integer overflow")
-)
+func init() {
+	proto.RegisterType((*Metrics)(nil), "io.containerd.cgroups.v1.Metrics")
+	proto.RegisterType((*HugetlbStat)(nil), "io.containerd.cgroups.v1.HugetlbStat")
+	proto.RegisterType((*PidsStat)(nil), "io.containerd.cgroups.v1.PidsStat")
+	proto.RegisterType((*CPUStat)(nil), "io.containerd.cgroups.v1.CPUStat")
+	proto.RegisterType((*CPUUsage)(nil), "io.containerd.cgroups.v1.CPUUsage")
+	proto.RegisterType((*Throttle)(nil), "io.containerd.cgroups.v1.Throttle")
+	proto.RegisterType((*MemoryStat)(nil), "io.containerd.cgroups.v1.MemoryStat")
+	proto.RegisterType((*MemoryEntry)(nil), "io.containerd.cgroups.v1.MemoryEntry")
+	proto.RegisterType((*BlkIOStat)(nil), "io.containerd.cgroups.v1.BlkIOStat")
+	proto.RegisterType((*BlkIOEntry)(nil), "io.containerd.cgroups.v1.BlkIOEntry")
+	proto.RegisterType((*RdmaStat)(nil), "io.containerd.cgroups.v1.RdmaStat")
+	proto.RegisterType((*RdmaEntry)(nil), "io.containerd.cgroups.v1.RdmaEntry")
+	proto.RegisterType((*NetworkStat)(nil), "io.containerd.cgroups.v1.NetworkStat")
+	proto.RegisterType((*FilesStat)(nil), "io.containerd.cgroups.v1.FilesStat")
+}
 
 func init() { proto.RegisterFile("github.com/containerd/cgroups/metrics.proto", fileDescriptorMetrics) }
 
 var fileDescriptorMetrics = []byte{
-	// 1549 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0x4d, 0x6f, 0x1b, 0xb7,
-	0x16, 0x8d, 0x2c, 0xd9, 0xd2, 0x5c, 0xd9, 0x8e, 0x4d, 0x27, 0xce, 0xd8, 0x49, 0x2c, 0x47, 0xb6,
-	0xdf, 0xf3, 0x7b, 0x06, 0x64, 0xbc, 0x3c, 0x20, 0x68, 0xd2, 0x04, 0x45, 0xe4, 0x24, 0x48, 0xd0,
-	0xba, 0x51, 0x46, 0x36, 0xd2, 0xae, 0x06, 0xd4, 0x88, 0x19, 0xd1, 0x96, 0x86, 0x13, 0x0e, 0xc7,
-	0x96, 0xbb, 0xea, 0xa2, 0x40, 0x57, 0xfd, 0x33, 0xfd, 0x15, 0x59, 0x76, 0x53, 0xa0, 0xdd, 0x18,
-	0x8d, 0x7e, 0x49, 0x41, 0x72, 0x3e, 0xa8, 0x24, 0x8e, 0xab, 0xdd, 0x90, 0x3c, 0xe7, 0xdc, 0xcb,
-	0x3b, 0x87, 0xc3, 0x3b, 0xb0, 0xe3, 0x53, 0xd1, 0x8b, 0x3b, 0x0d, 0x8f, 0x0d, 0x76, 0x3d, 0x16,
-	0x08, 0x4c, 0x03, 0xc2, 0xbb, 0xbb, 0x9e, 0xcf, 0x59, 0x1c, 0x46, 0xbb, 0x03, 0x22, 0x38, 0xf5,
-	0xa2, 0x46, 0xc8, 0x99, 0x60, 0xc8, 0xa6, 0xac, 0x91, 0x83, 0x1a, 0x09, 0xa8, 0x71, 0xf2, 0xbf,
-	0xd5, 0x6b, 0x3e, 0xf3, 0x99, 0x02, 0xed, 0xca, 0x27, 0x8d, 0xaf, 0xff, 0x5a, 0x84, 0xf2, 0xbe,
-	0x56, 0x40, 0x5f, 0x41, 0xb9, 0x17, 0xfb, 0x44, 0xf4, 0x3b, 0x76, 0x61, 0xbd, 0xb8, 0x5d, 0xbd,
-	0xbb, 0xd5, 0xb8, 0x48, 0xad, 0xf1, 0x5c, 0x03, 0xdb, 0x02, 0x0b, 0x27, 0x65, 0xa1, 0x7b, 0x50,
-	0x0a, 0x69, 0x37, 0xb2, 0xa7, 0xd6, 0x0b, 0xdb, 0xd5, 0xbb, 0xf5, 0x8b, 0xd9, 0x2d, 0xda, 0x8d,
-	0x14, 0x55, 0xe1, 0xd1, 0x43, 0x28, 0x7a, 0x61, 0x6c, 0x17, 0x15, 0xed, 0xce, 0xc5, 0xb4, 0xbd,
-	0xd6, 0xa1, 0x64, 0x35, 0xcb, 0xa3, 0xf3, 0x5a, 0x71, 0xaf, 0x75, 0xe8, 0x48, 0x1a, 0x7a, 0x08,
-	0x33, 0x03, 0x32, 0x60, 0xfc, 0xcc, 0x2e, 0x29, 0x81, 0xcd, 0x8b, 0x05, 0xf6, 0x15, 0x4e, 0x45,
-	0x4e, 0x38, 0xe8, 0x3e, 0x4c, 0x77, 0xfa, 0xc7, 0x94, 0xd9, 0xd3, 0x8a, 0xbc, 0x71, 0x31, 0xb9,
-	0xd9, 0x3f, 0x7e, 0xf1, 0x52, 0x71, 0x35, 0x43, 0x6e, 0x97, 0x77, 0x07, 0xd8, 0x9e, 0xb9, 0x6c,
-	0xbb, 0x4e, 0x77, 0x80, 0xf5, 0x76, 0x25, 0x5e, 0xd6, 0x39, 0x20, 0xe2, 0x94, 0xf1, 0x63, 0xbb,
-	0x7c, 0x59, 0x9d, 0xbf, 0xd5, 0x40, 0x5d, 0xe7, 0x84, 0x55, 0x3f, 0x86, 0xaa, 0x51, 0x7f, 0x74,
-	0x0d, 0xa6, 0xe3, 0x08, 0xfb, 0xc4, 0x2e, 0xac, 0x17, 0xb6, 0x4b, 0x8e, 0x1e, 0xa0, 0x05, 0x28,
-	0x0e, 0xf0, 0x50, 0xbd, 0x8b, 0x92, 0x23, 0x1f, 0x91, 0x0d, 0xe5, 0x37, 0x98, 0xf6, 0xbd, 0x40,
-	0xa8, 0x52, 0x97, 0x9c, 0x74, 0x88, 0x56, 0xa1, 0x12, 0x62, 0x9f, 0x44, 0xf4, 0x07, 0xa2, 0x8a,
-	0x68, 0x39, 0xd9, 0xb8, 0xfe, 0x00, 0x2a, 0xe9, 0xeb, 0x92, 0x0a, 0x5e, 0xcc, 0x39, 0x09, 0x44,
-	0x12, 0x2b, 0x1d, 0xca, 0x1c, 0xfa, 0x74, 0x40, 0x45, 0x12, 0x4f, 0x0f, 0xea, 0x3f, 0x17, 0xa0,
-	0x9c, 0xbc, 0x34, 0xf4, 0x85, 0x99, 0xe5, 0x67, 0xcb, 0xb5, 0xd7, 0x3a, 0x3c, 0x94, 0xc8, 0x74,
-	0x27, 0x4d, 0x00, 0xd1, 0xe3, 0x4c, 0x88, 0x3e, 0x0d, 0xfc, 0xcb, 0xcd, 0x75, 0xa0, 0xb1, 0xc4,
-	0x31, 0x58, 0xf5, 0xb7, 0x50, 0x49, 0x65, 0x65, 0xae, 0x82, 0x09, 0xdc, 0x4f, 0xeb, 0xa5, 0x06,
-	0x68, 0x19, 0x66, 0x8e, 0x09, 0x0f, 0x48, 0x3f, 0xd9, 0x42, 0x32, 0x42, 0x08, 0x4a, 0x71, 0x44,
-	0x78, 0x52, 0x32, 0xf5, 0x8c, 0x36, 0xa0, 0x1c, 0x12, 0xee, 0x4a, 0xd3, 0x96, 0xd6, 0x8b, 0xdb,
-	0xa5, 0x26, 0x8c, 0xce, 0x6b, 0x33, 0x2d, 0xc2, 0xa5, 0x29, 0x67, 0x42, 0xc2, 0xf7, 0xc2, 0xb8,
-	0x3e, 0x84, 0x4a, 0x9a, 0x8a, 0x2c, 0x5c, 0x48, 0x38, 0x65, 0xdd, 0x28, 0x2d, 0x5c, 0x32, 0x44,
-	0x3b, 0xb0, 0x98, 0xa4, 0x49, 0xba, 0x6e, 0x8a, 0xd1, 0x19, 0x2c, 0x64, 0x0b, 0xad, 0x04, 0xbc,
-	0x05, 0xf3, 0x39, 0x58, 0xd0, 0x01, 0x49, 0xb2, 0x9a, 0xcb, 0x66, 0x0f, 0xe8, 0x80, 0xd4, 0xff,
-	0xac, 0x02, 0xe4, 0x56, 0x97, 0xfb, 0xf5, 0xb0, 0xd7, 0xcb, 0xfc, 0xa1, 0x06, 0x68, 0x05, 0x8a,
-	0x3c, 0x4a, 0x42, 0xe9, 0x13, 0xe5, 0xb4, 0xdb, 0x8e, 0x9c, 0x43, 0xff, 0x82, 0x0a, 0x8f, 0x22,
-	0x57, 0x1e, 0x6b, 0x1d, 0xa0, 0x59, 0x1d, 0x9d, 0xd7, 0xca, 0x4e, 0xbb, 0x2d, 0x6d, 0xe7, 0x94,
-	0x79, 0x14, 0xc9, 0x07, 0x54, 0x83, 0xea, 0x00, 0x87, 0x21, 0xe9, 0xba, 0x6f, 0x68, 0x5f, 0x3b,
-	0xa7, 0xe4, 0x80, 0x9e, 0x7a, 0x46, 0xfb, 0xaa, 0xd2, 0x5d, 0xca, 0xc5, 0x99, 0x3a, 0x5c, 0x25,
-	0x47, 0x0f, 0xd0, 0x2d, 0xb0, 0x4e, 0x39, 0x15, 0xa4, 0x83, 0xbd, 0x63, 0x75, 0x78, 0x4a, 0x4e,
-	0x3e, 0x81, 0x6c, 0xa8, 0x84, 0xbe, 0x1b, 0xfa, 0x2e, 0x0d, 0xec, 0xb2, 0x7e, 0x13, 0xa1, 0xdf,
-	0xf2, 0x5f, 0x04, 0x68, 0x15, 0x2c, 0xbd, 0xc2, 0x62, 0x61, 0x57, 0x92, 0x32, 0xfa, 0x2d, 0xff,
-	0x65, 0x2c, 0xd0, 0x8a, 0x62, 0xbd, 0xc1, 0x71, 0x5f, 0xd8, 0x56, 0xba, 0xf4, 0x4c, 0x0e, 0xd1,
-	0x3a, 0xcc, 0x86, 0xbe, 0x3b, 0xc0, 0x47, 0xc9, 0x32, 0xe8, 0x34, 0x43, 0x7f, 0x1f, 0x1f, 0x69,
-	0xc4, 0x06, 0xcc, 0xd1, 0x00, 0x7b, 0x82, 0x9e, 0x10, 0x17, 0x07, 0x2c, 0xb0, 0xab, 0x0a, 0x32,
-	0x9b, 0x4e, 0x3e, 0x0e, 0x58, 0x20, 0x37, 0x6b, 0x42, 0x66, 0xb5, 0x8a, 0x01, 0x30, 0x55, 0x54,
-	0x3d, 0xe6, 0xc6, 0x55, 0x54, 0x45, 0x72, 0x15, 0x05, 0x99, 0x37, 0x55, 0x14, 0x60, 0x1d, 0xaa,
-	0x71, 0x40, 0x4e, 0xa8, 0x27, 0x70, 0xa7, 0x4f, 0xec, 0xab, 0x0a, 0x60, 0x4e, 0xa1, 0x07, 0xb0,
-	0xd2, 0xa3, 0x84, 0x63, 0xee, 0xf5, 0xa8, 0x87, 0xfb, 0xae, 0xfe, 0x90, 0xb9, 0xfa, 0xf8, 0x2d,
-	0x28, 0xfc, 0x0d, 0x13, 0xa0, 0x9d, 0xf0, 0x8d, 0x5c, 0x46, 0xf7, 0x60, 0x6c, 0xc9, 0x8d, 0x4e,
-	0x71, 0x98, 0x30, 0x17, 0x15, 0xf3, 0xba, 0xb9, 0xdc, 0x3e, 0xc5, 0xa1, 0xe6, 0xd5, 0xa0, 0xaa,
-	0x4e, 0x89, 0xab, 0x8d, 0x84, 0x74, 0xda, 0x6a, 0x6a, 0x4f, 0xb9, 0xe9, 0x3f, 0x60, 0x69, 0x80,
-	0xf4, 0xd4, 0x92, 0xf2, 0xcc, 0xec, 0xe8, 0xbc, 0x56, 0x39, 0x90, 0x93, 0xd2, 0x58, 0x15, 0xb5,
-	0xec, 0x44, 0x11, 0xba, 0x07, 0xf3, 0x19, 0x54, 0x7b, 0xec, 0x9a, 0xc2, 0x2f, 0x8c, 0xce, 0x6b,
-	0xb3, 0x29, 0x5e, 0x19, 0x6d, 0x36, 0xe5, 0x28, 0xb7, 0xfd, 0x17, 0x16, 0x35, 0xcf, 0xf4, 0xdc,
-	0x75, 0x95, 0xc9, 0x55, 0xb5, 0xb0, 0x9f, 0x1b, 0x2f, 0xcb, 0x57, 0xdb, 0x6f, 0xd9, 0xc8, 0xf7,
-	0x89, 0xf2, 0xe0, 0xbf, 0x41, 0x73, 0xdc, 0xdc, 0x89, 0x37, 0x14, 0x48, 0xe7, 0xf6, 0x3a, 0xb3,
-	0xe3, 0x46, 0x9a, 0x6d, 0x66, 0x4a, 0x5b, 0xbf, 0x12, 0x35, 0xdb, 0xd2, 0xce, 0xdc, 0x4a, 0xd5,
-	0x72, 0x7f, 0xae, 0xe8, 0x97, 0x9f, 0xa1, 0xa4, 0x49, 0x37, 0x0d, 0x2d, 0xed, 0xc5, 0xd5, 0x31,
-	0x94, 0x76, 0xe3, 0x0e, 0xa0, 0x0c, 0x95, 0xbb, 0xf6, 0xa6, 0xb1, 0xd1, 0x56, 0x6e, 0xdd, 0x06,
-	0x2c, 0x69, 0xf0, 0xb8, 0x81, 0x6f, 0x29, 0xb4, 0xae, 0xd7, 0x0b, 0xd3, 0xc5, 0x59, 0x11, 0x4d,
-	0xf4, 0x6d, 0x43, 0xfb, 0x71, 0x8e, 0xfd, 0x58, 0x5b, 0x95, 0x7c, 0xed, 0x13, 0xda, 0xaa, 0xe8,
-	0x1f, 0x6a, 0x2b, 0x74, 0xed, 0x23, 0x6d, 0x85, 0xdd, 0x49, 0xb1, 0xa6, 0xd9, 0xd7, 0x93, 0xcf,
-	0x9e, 0x5c, 0x38, 0x34, 0x1c, 0xff, 0x65, 0x7a, 0x75, 0xdc, 0x51, 0xdf, 0xfe, 0xad, 0xcb, 0x2e,
-	0xf8, 0xa7, 0x81, 0xe0, 0x67, 0xe9, 0xed, 0x71, 0x1f, 0x4a, 0xd2, 0xe5, 0x76, 0x7d, 0x12, 0xae,
-	0xa2, 0xa0, 0x47, 0xd9, 0x95, 0xb0, 0x31, 0x09, 0x39, 0xbd, 0x39, 0xda, 0x00, 0xfa, 0xc9, 0x15,
-	0x5e, 0x68, 0x6f, 0x4e, 0x20, 0xd1, 0x9c, 0x1b, 0x9d, 0xd7, 0xac, 0xaf, 0x15, 0xf9, 0x60, 0xaf,
-	0xe5, 0x58, 0x5a, 0xe7, 0xc0, 0x0b, 0xeb, 0x04, 0xaa, 0x06, 0x30, 0xbf, 0x77, 0x0b, 0xc6, 0xbd,
-	0x9b, 0x77, 0x04, 0x53, 0x9f, 0xe8, 0x08, 0x8a, 0x9f, 0xec, 0x08, 0x4a, 0x63, 0x1d, 0x41, 0xfd,
-	0xf7, 0x69, 0xb0, 0xb2, 0x86, 0x07, 0x61, 0x58, 0xa5, 0xcc, 0x8d, 0x08, 0x3f, 0xa1, 0x1e, 0x71,
-	0x3b, 0x67, 0x82, 0x44, 0x2e, 0x27, 0x5e, 0xcc, 0x23, 0x7a, 0x42, 0x92, 0x66, 0x71, 0xf3, 0x92,
-	0xce, 0x49, 0xd7, 0xe6, 0x06, 0x65, 0x6d, 0x2d, 0xd3, 0x94, 0x2a, 0x4e, 0x2a, 0x82, 0xbe, 0x83,
-	0xeb, 0x79, 0x88, 0xae, 0xa1, 0x3e, 0x35, 0x81, 0xfa, 0x52, 0xa6, 0xde, 0xcd, 0x95, 0x0f, 0x60,
-	0x89, 0x32, 0xf7, 0x6d, 0x4c, 0xe2, 0x31, 0xdd, 0xe2, 0x04, 0xba, 0x8b, 0x94, 0xbd, 0x52, 0xfc,
-	0x5c, 0xd5, 0x85, 0x15, 0xa3, 0x24, 0xf2, 0x2e, 0x36, 0xb4, 0x4b, 0x13, 0x68, 0x2f, 0x67, 0x39,
-	0xcb, 0xbb, 0x3b, 0x0f, 0xf0, 0x3d, 0x2c, 0x53, 0xe6, 0x9e, 0x62, 0x2a, 0x3e, 0x54, 0x9f, 0x9e,
-	0xac, 0x22, 0xaf, 0x31, 0x15, 0xe3, 0xd2, 0xba, 0x22, 0x03, 0xc2, 0xfd, 0xb1, 0x8a, 0xcc, 0x4c,
-	0x56, 0x91, 0x7d, 0xc5, 0xcf, 0x55, 0x5b, 0xb0, 0x48, 0xd9, 0x87, 0xb9, 0x96, 0x27, 0xd0, 0xbc,
-	0x4a, 0xd9, 0x78, 0x9e, 0xaf, 0x60, 0x31, 0x22, 0x9e, 0x60, 0xdc, 0x74, 0x5b, 0x65, 0x02, 0xc5,
-	0x85, 0x84, 0x9e, 0x49, 0xd6, 0x4f, 0x00, 0xf2, 0x75, 0x34, 0x0f, 0x53, 0x2c, 0x54, 0x47, 0xc7,
-	0x72, 0xa6, 0x58, 0x28, 0x7b, 0xc0, 0xae, 0xfc, 0xec, 0xe8, 0x83, 0x63, 0x39, 0xc9, 0x48, 0x9e,
-	0xa7, 0x01, 0x3e, 0x62, 0x69, 0x13, 0xa8, 0x07, 0x6a, 0x96, 0x06, 0x8c, 0x27, 0x67, 0x47, 0x0f,
-	0xe4, 0xec, 0x09, 0xee, 0xc7, 0x24, 0xed, 0x79, 0xd4, 0xa0, 0xfe, 0x53, 0x01, 0x2a, 0xe9, 0x6f,
-	0x00, 0x7a, 0x64, 0xb6, 0xd1, 0xc5, 0xcf, 0xff, 0x75, 0x48, 0x92, 0xde, 0x4c, 0xd6, 0x6b, 0xdf,
-	0xcf, 0x7b, 0xed, 0x7f, 0x4c, 0x4e, 0x1a, 0x72, 0x02, 0x56, 0x36, 0x67, 0xec, 0xb6, 0x30, 0xb6,
-	0xdb, 0x1a, 0x54, 0x7b, 0x1e, 0x76, 0x7b, 0x38, 0xe8, 0xf6, 0x89, 0xee, 0x10, 0xe7, 0x1c, 0xe8,
-	0x79, 0xf8, 0xb9, 0x9e, 0x49, 0x01, 0xac, 0x73, 0x44, 0x3c, 0x11, 0xa9, 0xa2, 0x68, 0xc0, 0x4b,
-	0x3d, 0x53, 0xff, 0x65, 0x0a, 0xaa, 0xc6, 0x9f, 0x8b, 0xec, 0xa1, 0x03, 0x3c, 0x48, 0xe3, 0xa8,
-	0x67, 0xd9, 0xb1, 0xf1, 0xa1, 0xfe, 0x96, 0x24, 0x9f, 0xa9, 0x32, 0x1f, 0xaa, 0x8f, 0x02, 0xba,
-	0x0d, 0xc0, 0x87, 0x6e, 0x88, 0xbd, 0x63, 0x92, 0xc8, 0x97, 0x1c, 0x8b, 0x0f, 0x5b, 0x7a, 0x02,
-	0xdd, 0x04, 0x8b, 0x0f, 0x5d, 0xc2, 0x39, 0xe3, 0x51, 0x52, 0xfb, 0x0a, 0x1f, 0x3e, 0x55, 0xe3,
-	0x84, 0xdb, 0xe5, 0x4c, 0xf6, 0x02, 0xc9, 0x3b, 0xb0, 0xf8, 0xf0, 0x89, 0x9e, 0x90, 0x51, 0x45,
-	0x1a, 0x55, 0xb7, 0x9e, 0x65, 0x91, 0x47, 0x15, 0x79, 0x54, 0xdd, 0x7a, 0x5a, 0xc2, 0x8c, 0x2a,
-	0xb2, 0xa8, 0xba, 0xfb, 0xac, 0x08, 0x23, 0xaa, 0xc8, 0xa3, 0x5a, 0x29, 0x37, 0x89, 0xda, 0xb4,
-	0xdf, 0xbd, 0x5f, 0xbb, 0xf2, 0xc7, 0xfb, 0xb5, 0x2b, 0x3f, 0x8e, 0xd6, 0x0a, 0xef, 0x46, 0x6b,
-	0x85, 0xdf, 0x46, 0x6b, 0x85, 0xbf, 0x46, 0x6b, 0x85, 0xce, 0x8c, 0xfa, 0x0d, 0xff, 0xff, 0xdf,
-	0x01, 0x00, 0x00, 0xff, 0xff, 0x19, 0x9d, 0xe2, 0xd3, 0xe5, 0x0f, 0x00, 0x00,
+	// 1542 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0x5f, 0x53, 0xdb, 0xc6,
+	0x17, 0x1d, 0x63, 0x83, 0xad, 0x6b, 0x20, 0xb0, 0x24, 0x44, 0x90, 0xe4, 0x67, 0x62, 0xe0, 0x57,
+	0x5a, 0x66, 0xcc, 0x34, 0x9d, 0x49, 0x9b, 0x34, 0x99, 0x4e, 0x20, 0xc9, 0x24, 0xd3, 0xd2, 0x38,
+	0x32, 0x4c, 0xda, 0x27, 0xcd, 0x5a, 0xde, 0xc8, 0x0b, 0xb6, 0x56, 0x59, 0xad, 0xc0, 0xf4, 0xb9,
+	0x33, 0x7d, 0xea, 0xc7, 0xeb, 0x43, 0x5f, 0x78, 0xe0, 0xbd, 0xdf, 0xa1, 0xb3, 0x77, 0xf5, 0xcf,
+	0x09, 0x84, 0xfa, 0x4d, 0xbb, 0x7b, 0xce, 0xb9, 0x77, 0xef, 0x9e, 0x95, 0xae, 0x60, 0xdb, 0xe7,
+	0xaa, 0x1f, 0x77, 0x5b, 0x9e, 0x18, 0xee, 0x78, 0x22, 0x50, 0x94, 0x07, 0x4c, 0xf6, 0x76, 0x3c,
+	0x5f, 0x8a, 0x38, 0x8c, 0x76, 0x86, 0x4c, 0x49, 0xee, 0x45, 0xad, 0x50, 0x0a, 0x25, 0x88, 0xcd,
+	0x45, 0x2b, 0x07, 0xb5, 0x12, 0x50, 0xeb, 0xe4, 0xeb, 0xd5, 0x9b, 0xbe, 0xf0, 0x05, 0x82, 0x76,
+	0xf4, 0x93, 0xc1, 0x37, 0xff, 0x29, 0x43, 0x75, 0xdf, 0x28, 0x90, 0x1f, 0xa0, 0xda, 0x8f, 0x7d,
+	0xa6, 0x06, 0x5d, 0xbb, 0xb4, 0x56, 0xde, 0xaa, 0x3f, 0xd8, 0x6c, 0x5d, 0xa5, 0xd6, 0x7a, 0x65,
+	0x80, 0x1d, 0x45, 0x95, 0x93, 0xb2, 0xc8, 0x43, 0xa8, 0x84, 0xbc, 0x17, 0xd9, 0x53, 0x6b, 0xa5,
+	0xad, 0xfa, 0x83, 0xe6, 0xd5, 0xec, 0x36, 0xef, 0x45, 0x48, 0x45, 0x3c, 0x79, 0x02, 0x65, 0x2f,
+	0x8c, 0xed, 0x32, 0xd2, 0xee, 0x5f, 0x4d, 0xdb, 0x6b, 0x1f, 0x6a, 0xd6, 0x6e, 0xf5, 0xe2, 0xbc,
+	0x51, 0xde, 0x6b, 0x1f, 0x3a, 0x9a, 0x46, 0x9e, 0xc0, 0xcc, 0x90, 0x0d, 0x85, 0x3c, 0xb3, 0x2b,
+	0x28, 0xb0, 0x71, 0xb5, 0xc0, 0x3e, 0xe2, 0x30, 0x72, 0xc2, 0x21, 0x8f, 0x60, 0xba, 0x3b, 0x38,
+	0xe6, 0xc2, 0x9e, 0x46, 0xf2, 0xfa, 0xd5, 0xe4, 0xdd, 0xc1, 0xf1, 0xeb, 0x37, 0xc8, 0x35, 0x0c,
+	0xbd, 0x5d, 0xd9, 0x1b, 0x52, 0x7b, 0xe6, 0xba, 0xed, 0x3a, 0xbd, 0x21, 0x35, 0xdb, 0xd5, 0x78,
+	0x5d, 0xe7, 0x80, 0xa9, 0x53, 0x21, 0x8f, 0xed, 0xea, 0x75, 0x75, 0xfe, 0xd9, 0x00, 0x4d, 0x9d,
+	0x13, 0x96, 0xce, 0xf9, 0x3d, 0x1f, 0xb0, 0xc8, 0xae, 0x5d, 0x97, 0xf3, 0x4b, 0x0d, 0x33, 0x39,
+	0x23, 0xa3, 0x79, 0x0c, 0xf5, 0xc2, 0xd1, 0x91, 0x9b, 0x30, 0x1d, 0x47, 0xd4, 0x67, 0x76, 0x69,
+	0xad, 0xb4, 0x55, 0x71, 0xcc, 0x80, 0x2c, 0x40, 0x79, 0x48, 0x47, 0x78, 0x8c, 0x15, 0x47, 0x3f,
+	0x12, 0x1b, 0xaa, 0xef, 0x29, 0x1f, 0x78, 0x81, 0xc2, 0x53, 0xaa, 0x38, 0xe9, 0x90, 0xac, 0x42,
+	0x2d, 0xa4, 0x3e, 0x8b, 0xf8, 0x6f, 0x0c, 0xeb, 0x6f, 0x39, 0xd9, 0xb8, 0xf9, 0x18, 0x6a, 0xe9,
+	0x49, 0x6b, 0x05, 0x2f, 0x96, 0x92, 0x05, 0x2a, 0x89, 0x95, 0x0e, 0x75, 0x0e, 0x03, 0x3e, 0xe4,
+	0x2a, 0x89, 0x67, 0x06, 0xcd, 0x3f, 0x4a, 0x50, 0x4d, 0xce, 0x9b, 0x7c, 0x57, 0xcc, 0xf2, 0xb3,
+	0x95, 0xde, 0x6b, 0x1f, 0x1e, 0x6a, 0x64, 0xba, 0x93, 0x5d, 0x00, 0xd5, 0x97, 0x42, 0xa9, 0x01,
+	0x0f, 0xfc, 0xeb, 0x7d, 0x79, 0x60, 0xb0, 0xcc, 0x29, 0xb0, 0x9a, 0x1f, 0xa0, 0x96, 0xca, 0xea,
+	0x5c, 0x95, 0x50, 0x74, 0x90, 0xd6, 0x0b, 0x07, 0x64, 0x19, 0x66, 0x8e, 0x99, 0x0c, 0xd8, 0x20,
+	0xd9, 0x42, 0x32, 0x22, 0x04, 0x2a, 0x71, 0xc4, 0x64, 0x52, 0x32, 0x7c, 0x26, 0xeb, 0x50, 0x0d,
+	0x99, 0x74, 0xb5, 0xdf, 0x2b, 0x6b, 0xe5, 0xad, 0xca, 0x2e, 0x5c, 0x9c, 0x37, 0x66, 0xda, 0x4c,
+	0x6a, 0x3f, 0xcf, 0x84, 0x4c, 0xee, 0x85, 0x71, 0x73, 0x04, 0xb5, 0x34, 0x15, 0x5d, 0xb8, 0x90,
+	0x49, 0x2e, 0x7a, 0x51, 0x5a, 0xb8, 0x64, 0x48, 0xb6, 0x61, 0x31, 0x49, 0x93, 0xf5, 0xdc, 0x14,
+	0x63, 0x32, 0x58, 0xc8, 0x16, 0xda, 0x09, 0x78, 0x13, 0xe6, 0x73, 0xb0, 0xe2, 0x43, 0x96, 0x64,
+	0x35, 0x97, 0xcd, 0x1e, 0xf0, 0x21, 0x6b, 0xfe, 0x5d, 0x07, 0xc8, 0x6f, 0x89, 0xde, 0xaf, 0x47,
+	0xbd, 0x7e, 0xe6, 0x0f, 0x1c, 0x90, 0x15, 0x28, 0xcb, 0x28, 0x09, 0x65, 0x2e, 0xa3, 0xd3, 0xe9,
+	0x38, 0x7a, 0x8e, 0xfc, 0x1f, 0x6a, 0x32, 0x8a, 0x5c, 0xfd, 0x46, 0x30, 0x01, 0x76, 0xeb, 0x17,
+	0xe7, 0x8d, 0xaa, 0xd3, 0xe9, 0x68, 0xdb, 0x39, 0x55, 0x19, 0x45, 0xfa, 0x81, 0x34, 0xa0, 0x3e,
+	0xa4, 0x61, 0xc8, 0x7a, 0xae, 0xf6, 0x25, 0x3a, 0xa7, 0xe2, 0x80, 0x99, 0xd2, 0xa6, 0xd5, 0x91,
+	0x7b, 0x5c, 0xaa, 0x33, 0xbc, 0x97, 0x15, 0xc7, 0x0c, 0xc8, 0x5d, 0xb0, 0x4e, 0x25, 0x57, 0xac,
+	0x4b, 0xbd, 0x63, 0xbc, 0x77, 0x15, 0x27, 0x9f, 0x20, 0x36, 0xd4, 0x42, 0xdf, 0x0d, 0x7d, 0x97,
+	0x07, 0x76, 0xd5, 0x9c, 0x44, 0xe8, 0xb7, 0xfd, 0xd7, 0x01, 0x59, 0x05, 0xcb, 0xac, 0x88, 0x58,
+	0xe1, 0xad, 0xd1, 0x65, 0xf4, 0xdb, 0xfe, 0x9b, 0x58, 0x91, 0x15, 0x64, 0xbd, 0xa7, 0xf1, 0x40,
+	0xd9, 0x56, 0xba, 0xf4, 0x52, 0x0f, 0xc9, 0x1a, 0xcc, 0x86, 0xbe, 0x3b, 0xa4, 0x47, 0xc9, 0x32,
+	0x98, 0x34, 0x43, 0x7f, 0x9f, 0x1e, 0x19, 0xc4, 0x3a, 0xcc, 0xf1, 0x80, 0x7a, 0x8a, 0x9f, 0x30,
+	0x97, 0x06, 0x22, 0xb0, 0xeb, 0x08, 0x99, 0x4d, 0x27, 0x9f, 0x05, 0x22, 0xd0, 0x9b, 0x2d, 0x42,
+	0x66, 0x8d, 0x4a, 0x01, 0x50, 0x54, 0xc1, 0x7a, 0xcc, 0x8d, 0xab, 0x60, 0x45, 0x72, 0x15, 0x84,
+	0xcc, 0x17, 0x55, 0x10, 0xb0, 0x06, 0xf5, 0x38, 0x60, 0x27, 0xdc, 0x53, 0xb4, 0x3b, 0x60, 0xf6,
+	0x0d, 0x04, 0x14, 0xa7, 0xc8, 0x63, 0x58, 0xe9, 0x73, 0x26, 0xa9, 0xf4, 0xfa, 0xdc, 0xa3, 0x03,
+	0xd7, 0xbc, 0x03, 0x5d, 0x73, 0xfd, 0x16, 0x10, 0x7f, 0xbb, 0x08, 0x30, 0x4e, 0xf8, 0x49, 0x2f,
+	0x93, 0x87, 0x30, 0xb6, 0xe4, 0x46, 0xa7, 0x34, 0x4c, 0x98, 0x8b, 0xc8, 0xbc, 0x55, 0x5c, 0xee,
+	0x9c, 0xd2, 0xd0, 0xf0, 0x1a, 0x50, 0xc7, 0x5b, 0xe2, 0x1a, 0x23, 0x11, 0x93, 0x36, 0x4e, 0xed,
+	0xa1, 0x9b, 0xbe, 0x04, 0xcb, 0x00, 0xb4, 0xa7, 0x96, 0xd0, 0x33, 0xb3, 0x17, 0xe7, 0x8d, 0xda,
+	0x81, 0x9e, 0xd4, 0xc6, 0xaa, 0xe1, 0xb2, 0x13, 0x45, 0xe4, 0x21, 0xcc, 0x67, 0x50, 0xe3, 0xb1,
+	0x9b, 0x88, 0x5f, 0xb8, 0x38, 0x6f, 0xcc, 0xa6, 0x78, 0x34, 0xda, 0x6c, 0xca, 0x41, 0xb7, 0x7d,
+	0x05, 0x8b, 0x86, 0x57, 0xf4, 0xdc, 0x2d, 0xcc, 0xe4, 0x06, 0x2e, 0xec, 0xe7, 0xc6, 0xcb, 0xf2,
+	0x35, 0xf6, 0x5b, 0x2e, 0xe4, 0xfb, 0x1c, 0x3d, 0xf8, 0x05, 0x18, 0x8e, 0x9b, 0x3b, 0xf1, 0x36,
+	0x82, 0x4c, 0x6e, 0xef, 0x32, 0x3b, 0xae, 0xa7, 0xd9, 0x66, 0xa6, 0xb4, 0xcd, 0x91, 0xe0, 0x6c,
+	0xdb, 0x38, 0x73, 0x33, 0x55, 0xcb, 0xfd, 0xb9, 0x62, 0x0e, 0x3f, 0x43, 0x69, 0x93, 0x6e, 0x14,
+	0xb4, 0x8c, 0x17, 0x57, 0xc7, 0x50, 0xc6, 0x8d, 0xdb, 0x40, 0x32, 0x54, 0xee, 0xda, 0x3b, 0x85,
+	0x8d, 0xb6, 0x73, 0xeb, 0xb6, 0x60, 0xc9, 0x80, 0xc7, 0x0d, 0x7c, 0x17, 0xd1, 0xa6, 0x5e, 0xaf,
+	0x8b, 0x2e, 0xce, 0x8a, 0x58, 0x44, 0xdf, 0x2b, 0x68, 0x3f, 0xcb, 0xb1, 0x9f, 0x6a, 0x63, 0xc9,
+	0xff, 0x77, 0x89, 0x36, 0x16, 0xfd, 0x63, 0x6d, 0x44, 0x37, 0x3e, 0xd1, 0x46, 0xec, 0x76, 0x8a,
+	0x2d, 0x9a, 0x7d, 0x2d, 0x79, 0xed, 0xe9, 0x85, 0xc3, 0x82, 0xe3, 0xbf, 0x4f, 0x3f, 0x1d, 0xf7,
+	0xf1, 0xdd, 0xbf, 0x79, 0x5d, 0x6f, 0xf0, 0x22, 0x50, 0xf2, 0x2c, 0xfd, 0x7a, 0x3c, 0x82, 0x8a,
+	0x76, 0xb9, 0xdd, 0x9c, 0x84, 0x8b, 0x14, 0xf2, 0x34, 0xfb, 0x24, 0xac, 0x4f, 0x42, 0x4e, 0xbf,
+	0x1c, 0x1d, 0x00, 0xf3, 0xe4, 0x2a, 0x2f, 0xb4, 0x37, 0x26, 0x90, 0xd8, 0x9d, 0xbb, 0x38, 0x6f,
+	0x58, 0x3f, 0x22, 0xf9, 0x60, 0xaf, 0xed, 0x58, 0x46, 0xe7, 0xc0, 0x0b, 0x9b, 0x0c, 0xea, 0x05,
+	0x60, 0xfe, 0xdd, 0x2d, 0x15, 0xbe, 0xbb, 0x79, 0x47, 0x30, 0x75, 0x49, 0x47, 0x50, 0xbe, 0xb4,
+	0x23, 0xa8, 0x8c, 0x75, 0x04, 0xcd, 0xbf, 0xa6, 0xc1, 0xca, 0x7a, 0x25, 0x42, 0x61, 0x95, 0x0b,
+	0x37, 0x62, 0xf2, 0x84, 0x7b, 0xcc, 0xed, 0x9e, 0x29, 0x16, 0xb9, 0x92, 0x79, 0xb1, 0x8c, 0xf8,
+	0x09, 0x4b, 0xfa, 0xcc, 0x8d, 0x6b, 0x9a, 0x2e, 0x53, 0x9b, 0xdb, 0x5c, 0x74, 0x8c, 0xcc, 0xae,
+	0x56, 0x71, 0x52, 0x11, 0xf2, 0x0b, 0xdc, 0xca, 0x43, 0xf4, 0x0a, 0xea, 0x53, 0x13, 0xa8, 0x2f,
+	0x65, 0xea, 0xbd, 0x5c, 0xf9, 0x00, 0x96, 0xb8, 0x70, 0x3f, 0xc4, 0x2c, 0x1e, 0xd3, 0x2d, 0x4f,
+	0xa0, 0xbb, 0xc8, 0xc5, 0x5b, 0xe4, 0xe7, 0xaa, 0x2e, 0xac, 0x14, 0x4a, 0xa2, 0xbf, 0xc5, 0x05,
+	0xed, 0xca, 0x04, 0xda, 0xcb, 0x59, 0xce, 0xfa, 0xdb, 0x9d, 0x07, 0xf8, 0x15, 0x96, 0xb9, 0x70,
+	0x4f, 0x29, 0x57, 0x1f, 0xab, 0x4f, 0x4f, 0x56, 0x91, 0x77, 0x94, 0xab, 0x71, 0x69, 0x53, 0x91,
+	0x21, 0x93, 0xfe, 0x58, 0x45, 0x66, 0x26, 0xab, 0xc8, 0x3e, 0xf2, 0x73, 0xd5, 0x36, 0x2c, 0x72,
+	0xf1, 0x71, 0xae, 0xd5, 0x09, 0x34, 0x6f, 0x70, 0x31, 0x9e, 0xe7, 0x5b, 0x58, 0x8c, 0x98, 0xa7,
+	0x84, 0x2c, 0xba, 0xad, 0x36, 0x81, 0xe2, 0x42, 0x42, 0xcf, 0x24, 0x9b, 0x27, 0x00, 0xf9, 0x3a,
+	0x99, 0x87, 0x29, 0x11, 0xe2, 0xd5, 0xb1, 0x9c, 0x29, 0x11, 0xea, 0x1e, 0xb0, 0xa7, 0x5f, 0x3b,
+	0xe6, 0xe2, 0x58, 0x4e, 0x32, 0xd2, 0xf7, 0x69, 0x48, 0x8f, 0x44, 0xda, 0x04, 0x9a, 0x01, 0xce,
+	0xf2, 0x40, 0xc8, 0xe4, 0xee, 0x98, 0x81, 0x9e, 0x3d, 0xa1, 0x83, 0x98, 0xa5, 0x3d, 0x0f, 0x0e,
+	0x9a, 0xbf, 0x97, 0xa0, 0x96, 0xfe, 0x41, 0x90, 0xa7, 0xc5, 0x36, 0xba, 0xfc, 0xf9, 0xe6, 0x5f,
+	0x93, 0xcc, 0x66, 0xb2, 0x5e, 0xfb, 0x51, 0xde, 0x6b, 0xff, 0x67, 0x72, 0xd2, 0x90, 0x33, 0xb0,
+	0xb2, 0xb9, 0xc2, 0x6e, 0x4b, 0x63, 0xbb, 0x6d, 0x40, 0xbd, 0xef, 0x51, 0xb7, 0x4f, 0x83, 0x9e,
+	0xfe, 0x3f, 0xd1, 0xa5, 0x98, 0x73, 0xa0, 0xef, 0xd1, 0x57, 0x66, 0x26, 0x05, 0x88, 0xee, 0x11,
+	0xf3, 0x54, 0x84, 0x45, 0x31, 0x80, 0x37, 0x66, 0xa6, 0xf9, 0xe7, 0x14, 0xd4, 0x0b, 0x3f, 0x3d,
+	0xba, 0x87, 0x0e, 0xe8, 0x30, 0x8d, 0x83, 0xcf, 0xba, 0x63, 0x93, 0x23, 0xf3, 0x2e, 0x49, 0x5e,
+	0x53, 0x55, 0x39, 0xc2, 0x97, 0x02, 0xb9, 0x07, 0x20, 0x47, 0x6e, 0x48, 0xbd, 0x63, 0x96, 0xc8,
+	0x57, 0x1c, 0x4b, 0x8e, 0xda, 0x66, 0x82, 0xdc, 0x01, 0x4b, 0x8e, 0x5c, 0x26, 0xa5, 0x90, 0x51,
+	0x52, 0xfb, 0x9a, 0x1c, 0xbd, 0xc0, 0x71, 0xc2, 0xed, 0x49, 0xa1, 0x7b, 0x81, 0xe4, 0x0c, 0x2c,
+	0x39, 0x7a, 0x6e, 0x26, 0x74, 0x54, 0x95, 0x46, 0x35, 0xad, 0x67, 0x55, 0xe5, 0x51, 0x55, 0x1e,
+	0xd5, 0xb4, 0x9e, 0x96, 0x2a, 0x46, 0x55, 0x59, 0x54, 0xd3, 0x7d, 0xd6, 0x54, 0x21, 0xaa, 0xca,
+	0xa3, 0x5a, 0x29, 0x37, 0x89, 0xda, 0xfc, 0x16, 0xac, 0xec, 0x27, 0xee, 0x8a, 0xdf, 0xb5, 0x4b,
+	0x7f, 0xa0, 0xba, 0x33, 0xf8, 0x83, 0xff, 0xcd, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x8a, 0x90,
+	0xfa, 0xea, 0x3f, 0x10, 0x00, 0x00,
 }
diff --git a/vendor/github.com/containerd/cgroups/subsystem.go b/vendor/github.com/containerd/cgroups/subsystem.go
index 23de04d..237fc4c 100644
--- a/vendor/github.com/containerd/cgroups/subsystem.go
+++ b/vendor/github.com/containerd/cgroups/subsystem.go
@@ -39,6 +39,7 @@ const (
 	Memory    Name = "memory"
 	Blkio     Name = "blkio"
 	Rdma      Name = "rdma"
+	Files     Name = "files"
 )
 
 // Subsystems returns a complete list of the default cgroups
@@ -57,6 +58,7 @@ func Subsystems() []Name {
 		Memory,
 		Blkio,
 		Rdma,
+		Files,
 	}
 	if !isUserNS {
 		n = append(n, Devices)
diff --git a/vendor/github.com/containerd/cgroups/utils.go b/vendor/github.com/containerd/cgroups/utils.go
index 82dbe2d..820b516 100644
--- a/vendor/github.com/containerd/cgroups/utils.go
+++ b/vendor/github.com/containerd/cgroups/utils.go
@@ -69,7 +69,6 @@ func defaults(root string) ([]Subsystem, error) {
 		return nil, err
 	}
 	s := []Subsystem{
-		NewNamed(root, "systemd"),
 		NewFreezer(root),
 		NewPids(root),
 		NewNetCls(root),
@@ -81,6 +80,7 @@ func defaults(root string) ([]Subsystem, error) {
 		NewMemory(root),
 		NewBlkio(root),
 		NewRdma(root),
+		NewFiles(root),
 	}
 	// only add the devices cgroup if we are not in a user namespace
 	// because modifications are not allowed
diff --git a/vendor/github.com/opencontainers/runtime-spec/specs-go/config.go b/vendor/github.com/opencontainers/runtime-spec/specs-go/config.go
index 27268f9..7a1acf2 100644
--- a/vendor/github.com/opencontainers/runtime-spec/specs-go/config.go
+++ b/vendor/github.com/opencontainers/runtime-spec/specs-go/config.go
@@ -332,6 +332,10 @@ type LinuxRdma struct {
 	HcaObjects *uint32 `json:"hcaObjects,omitempty"`
 }
 
+type Files struct {
+	Limit *uint64 `json:"limit,omitempty"`
+}
+
 // LinuxResources has container runtime resource constraints
 type LinuxResources struct {
 	// Devices configures the device whitelist.
@@ -352,6 +356,8 @@ type LinuxResources struct {
 	// Limits are a set of key value pairs that define RDMA resource limits,
 	// where the key is device name and value is resource limits.
 	Rdma map[string]LinuxRdma `json:"rdma,omitempty"`
+	// Files resource restriction configuration.
+	Files *Files `json:"files,omitempty"`
 }
 
 // LinuxDevice represents the mknod information for a Linux special device file
diff --git a/virtcontainers/cgroups.go b/virtcontainers/cgroups.go
index e8c5a7b..1b6b04d 100644
--- a/virtcontainers/cgroups.go
+++ b/virtcontainers/cgroups.go
@@ -11,6 +11,7 @@ import (
 	"context"
 	"encoding/json"
 	"fmt"
+	"io/ioutil"
 	"os"
 	"path/filepath"
 	"strconv"
@@ -35,6 +36,12 @@ const (
 	cgroupKataPath     = "/kata/"
 	vcpuCgroupName     = "vcpu"
 	emulatorCgroupName = "emulator"
+	fileCgroupName     = "files"
+
+	defaultMinFilesLimit uint64 = 1024
+	defaultMaxContainers uint64 = 200
+
+	procFileMaxPath = "/proc/sys/fs/file-max"
 
 	// BlkioThrottleReadBps is the key to fetch throttle_read_bps
 	BlkioThrottleReadBps = "throttle_read_bps"
@@ -414,6 +421,81 @@ func isInSlice(i int, s []int) bool {
 	return false
 }
 
+// supportFileCgroup check current host OS support files cgroup or not
+func supportFileCgroup() bool {
+	root, err := cgroupV1MountPoint()
+	if err != nil {
+		return false
+	}
+
+	filesCgroupPath := root + "/" + fileCgroupName
+	_, err = os.Stat(filesCgroupPath)
+	if err != nil {
+		return false
+	}
+
+	return true
+}
+
+func (s *Sandbox) filesResource(fileMaxPath string) *specs.Files {
+	var filesLimit uint64 = 0
+	var err error
+
+	// get fileslimit from sandbox container spec
+	sandboxContainerSpec := s.GetPatchedOCISpec()
+	if sandboxContainerSpec == nil || sandboxContainerSpec.Linux == nil {
+		return nil
+	}
+
+	var configFl uint64 = 0
+	sandboxResources := sandboxContainerSpec.Linux.Resources
+	if sandboxResources != nil && sandboxResources.Files != nil && sandboxResources.Files.Limit != nil {
+		configFl = *sandboxResources.Files.Limit
+	}
+
+	if configFl > 0 {
+		if configFl < defaultMinFilesLimit {
+			logrus.Warnf("At least %d fds are needed to support vm running", defaultMinFilesLimit)
+			filesLimit = defaultMinFilesLimit
+		} else {
+			filesLimit = configFl
+		}
+	} else {
+		filesLimit, err = getDefFilesLimitFromHost(fileMaxPath)
+		if err != nil {
+			// do nothing but print the warning log
+			logrus.Errorf("get default files limit failed : %#v", err)
+			return nil
+		}
+	}
+
+	return &specs.Files{
+		Limit: &filesLimit,
+	}
+}
+
+// getDefFilesLimitFromHost read default file-max files limit value from host
+func getDefFilesLimitFromHost(fileMaxPath string) (uint64, error) {
+	data, err := ioutil.ReadFile(fileMaxPath)
+	if err != nil {
+		return 0, fmt.Errorf("read file-max failed : %#v", err)
+	}
+
+	tmpFilesLimit, err := strconv.Atoi(strings.Replace(string(data), "\n", "", -1))
+	if err != nil {
+		return 0, fmt.Errorf("convert file-max failed : %#v", err)
+	}
+
+	var filesLimit uint64
+	// Distribute the maximum value of each container evenly, and take 50% as the default value
+	filesLimit = (uint64(tmpFilesLimit) / defaultMaxContainers) / 2
+	if filesLimit < defaultMinFilesLimit {
+		return 0, fmt.Errorf("file describe resource is shortage, require : %d, get : %d ", defaultMinFilesLimit, filesLimit)
+	}
+
+	return filesLimit, nil
+}
+
 func (s *Sandbox) blockIOResource() *specs.LinuxBlockIO {
 	value, ok := s.config.Annotations[annotations.BlkioCgroupTypeKey]
 	if !ok {
diff --git a/virtcontainers/fileslimit/fileslimit.c b/virtcontainers/fileslimit/fileslimit.c
new file mode 100644
index 0000000..0e9ae72
--- /dev/null
+++ b/virtcontainers/fileslimit/fileslimit.c
@@ -0,0 +1,23 @@
+// Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.
+// SPDX-License-Identifier: Apache-2.0
+// Description: common functions
+// Author: jiangpengfei
+// Create: 2019-06-12
+
+#define _GNU_SOURCE
+#include <time.h>
+#include <sys/resource.h>
+#include <errno.h>
+#include "fileslimit.h"
+
+int setProcessFilesLimit(int pid, int soft, int hard){
+    struct rlimit new;
+    new.rlim_cur = soft;
+    new.rlim_max = hard;
+
+    if (prlimit(pid, RLIMIT_NOFILE, &new, NULL) == -1) {
+        return errno;
+    }
+
+    return 0;
+}
diff --git a/virtcontainers/fileslimit/fileslimit.go b/virtcontainers/fileslimit/fileslimit.go
new file mode 100644
index 0000000..a0d2e2a
--- /dev/null
+++ b/virtcontainers/fileslimit/fileslimit.go
@@ -0,0 +1,23 @@
+// Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.
+// SPDX-License-Identifier: Apache-2.0
+// Description: common functions
+// Author: jiangpengfei
+// Create: 2019-06-12
+
+package fileslimit
+
+/*
+#cgo CFLAGS: -Wall
+extern int setProcessFilesLimit(int pid, int soft, int hard);
+*/
+import "C"
+import "fmt"
+
+func SetProcessFilesLimit(pid, soft, hard int) error {
+	ret := C.setProcessFilesLimit(C.int(pid), C.int(soft), C.int(hard))
+	if ret != 0 {
+		return fmt.Errorf("failed to set fileslimit of vm process ,errno:%d", ret)
+	}
+
+	return nil
+}
diff --git a/virtcontainers/fileslimit/fileslimit.h b/virtcontainers/fileslimit/fileslimit.h
new file mode 100644
index 0000000..4249d7a
--- /dev/null
+++ b/virtcontainers/fileslimit/fileslimit.h
@@ -0,0 +1,14 @@
+// Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.
+// SPDX-License-Identifier: Apache-2.0
+// Description: common functions
+// Author: jiangpengfei
+// Create: 2019-06-12
+
+#ifndef FILES_LIMIT_H
+#define FILES_LIMIT_H
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#endif /* FILES_LIMIT_H */
diff --git a/virtcontainers/sandbox.go b/virtcontainers/sandbox.go
index 9284f99..de8652f 100644
--- a/virtcontainers/sandbox.go
+++ b/virtcontainers/sandbox.go
@@ -27,6 +27,7 @@ import (
 	"github.com/kata-containers/runtime/virtcontainers/device/drivers"
 	deviceManager "github.com/kata-containers/runtime/virtcontainers/device/manager"
 	exp "github.com/kata-containers/runtime/virtcontainers/experimental"
+	"github.com/kata-containers/runtime/virtcontainers/fileslimit"
 	"github.com/kata-containers/runtime/virtcontainers/persist"
 	persistapi "github.com/kata-containers/runtime/virtcontainers/persist/api"
 	"github.com/kata-containers/runtime/virtcontainers/pkg/annotations"
@@ -2400,13 +2401,14 @@ func (s *Sandbox) setupHostCgroupsWithEmulator() error {
 		return fmt.Errorf("sandbox's cgroup %s doesn't exist", s.state.CgroupPath)
 	}
 
+	hypervisorPids := s.hypervisor.getPids()
+	if len(hypervisorPids) == 0 || hypervisorPids[0] == 0 {
+		return fmt.Errorf("hypervisor pid: %v invalid", hypervisorPids)
+	}
+
 	// pull out qemu threads other than vcpu to the cgroup of "<path>/emulator"
 	if s.config.HypervisorType == QemuHypervisor {
 		emulatorCgroupPath := filepath.Join(s.state.CgroupPath, emulatorCgroupName)
-		hypervisorPids := s.hypervisor.getPids()
-		if len(hypervisorPids) == 0 || hypervisorPids[0] == 0 {
-			return fmt.Errorf("hypervisor pid: %v invalid", hypervisorPids)
-		}
 		if err := pulloutQemuThread(s, hypervisorPids[0], emulatorCgroupPath); err != nil {
 			return err
 		}
@@ -2430,6 +2432,18 @@ func (s *Sandbox) setupHostCgroupsWithEmulator() error {
 	}
 
 	// limit files resource
+	filesResources := specs.LinuxResources{
+		Files: s.filesResource(procFileMaxPath),
+	}
+	if supportFileCgroup() {
+		if err := applyResourceLimit(&filesResources, vcpuCgroupPath); err != nil {
+			return err
+		}
+	} else {
+		if err := applyFilelimit(hypervisorPids[0], &filesResources); err != nil {
+			return err
+		}
+	}
 
 	return nil
 }
@@ -2451,6 +2465,22 @@ func applyResourceLimit(resources *specs.LinuxResources, cgroupPath string) erro
 	return nil
 }
 
+// apply files limit by pr_limit
+func applyFilelimit(vmPid int, resources *specs.LinuxResources) error {
+	if resources == nil {
+		return nil
+	}
+
+	filesLimit := *(resources.Files.Limit)
+
+	err := fileslimit.SetProcessFilesLimit(vmPid, int(filesLimit), int(filesLimit))
+	if err != nil {
+		return fmt.Errorf("set vm fileslimit failed.vmPid:%d, limit:%d, err:%v", vmPid, filesLimit, err.Error())
+	}
+
+	return nil
+}
+
 // GetPatchedOCISpec returns sandbox's OCI specification
 // This OCI specification was patched when the sandbox was created
 // by containerCapabilities(), SetEphemeralStorageType() and others
-- 
1.8.3.1

